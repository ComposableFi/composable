= Design Document: Apollo Price Oracle
:math:
:stem:
:imagesoutdir: images
:imagesdir: images
:toc:
:toclevels: 4
:sectnums:
:sectnumlevels: 4

== Abstract

This is a post-facto engineering design document for the Apollo price oracle.

== Background

Composable Finance plans to launch a decentralized price oracle to support the DeFi ecosystem in the Picasso parachain called Apollo. Apollo would provide access to asset prices from various price feeds coming from both centralized and decentralized off-chain sources such as decentralized/centralized exchanges. Bringing off-chain prices on-chain requires solving the infamous oracle problem.

=== What is the Oracle Problem?

The oracle problem in blockchains occur because of the need for pieces of logic running on a blockchain such as smart contracts to access off-chain data sources that do not fall within blockchain consensus and verifiability by definition and hence would not be natively "trustworthy" as they could be manipulated. For example if a smart contract running on Picasso parachain wants to access the price of ETH token it would require getting that price from an exchange such as Binance or Uniswap. But that runs the risk of the price being manipulated by the provider of the data or the original source itself causing the smart contract logic to derive wrong results. Avoiding this problem requires either implementing a) a fully trusted centralized oracle or b) a decentralized oracle. While the centralized approach could work for a variety of use cases, when designing a large DeFi ecosystem such as Picasso it's not the right choice as the oracle could become the weakest element in terms of security in the system.

=== Decentralized Price Oracles

A decentralized price oracle provides certain guarantees that a provided price is accurate and free of manipulation by employing a decentralized set of price providers instead of a single centralized one.
Refer https://hal.archives-ouvertes.fr/hal-03620931/document[[1]] or https://research.chain.link/whitepaper-v2.pdf[[2]] for more thorough coverage of the topics involved.

== Requirements

=== Utility

. Oracle MUST be configurable to provide prices for required assets types for the Picasso parachain DeFi ecosystem.
. Oracle MUST provide interfaces for any other on-chain protocol on Picasso to integrate with it to get price updates.
. Oracle MUST provide interfaces for any off-chain protocol such as a front end app to integrate with it to get price updates.
. Oracle system MUST be extensible to provide additional statistics on top of the Oracle prices such as time weighted average price(TWAP).

=== Accuracy (Observation Integrity)

Working under the assumption of an honest majority of Oracle providers,

. Oracle prices MUST be accurate to within a pre-defined level of error from the market consensus.
. Oracle prices MUST be resistant to temporary glitches in accuracy faced by a minority of the Oracle providers.

=== Security

Working under the assumption of an honest majority of Oracle providers,

. Oracle prices MUST be resistant to manipulation by an Oracle price provider.
. Oracle prices MUST be resistant to manipulation by a third party.
. Oracle MUST be resistant to denial of service attacks. i.e prices MUST be available at all required intervals.
. Oracle MUST be resistant to front-running.

=== Scalability

. The system MUST provide prices in the desired frequency(every `n` blocks) with low latency for the required asset types (Liveliness).
. The system MUST scale to be able to provide prices for any number of assets that Picasso DeFi ecosystem requires.

=== Decentralization

. The system MUST support the number of Oracle providers that governance deems necessary for the decentralization of the protocol.
. The system MUST support a wide variety of price sources.

== Method

=== System Overview

Following diagram illustrates an overview of the Apollo design with some minor components skipped over for clarity.

.Apollo Price Oracle: The System Overview
[plantuml,images/apollo-overview,png]
----
cloud "Oracle Provider Infra" {
    node "Picasso Parachain Node" {
        () "Oracle" as o
        package "Pallet Apollo" {
            Database "PrePrices" as prepricedb
            Database "AssetsInfo" as assetdb
            Database "OracleStake" as stakedb
            Database "Prices" as pricedb
            Database "PriceHistory" as pricehistorydb
            Database "RewardTrackerStore" as rewarddb
            [Offchain Worker] as ofw
            [on_init hook] as oih
            () "SubmitPrice" as sp
            () "AdjustRewards" as ar
            () "AddStake" as as
            () "AddAssetAndInfo" as adda
            ar --> rewarddb
            ofw --> sp
            sp --> prepricedb
            oih <-- prepricedb
            adda --> assetdb
            assetdb --> oih
            oih --> pricedb
            oih <--> stakedb : read/slash
            as --> stakedb
            oih --> pricehistorydb
        }

        ["Governance"] --> ar
        ["Governance"] --> adda
        rewarddb --> oih : block reward
        pricedb --> o
        pricehistorydb --> o
    }

    package "Price Feed Server" {
        () "Rest API" as papi
        database "Price Cache" as pc
        () "Client 1 - Binance Client" as c1
        () "Client 2 - Pyth Client" as c2
        () ".. Client n" as cn

        pc --> papi
        c1 --> pc: price feed
        c2 --> pc: price feed
        cn --> pc: price feed
        c1 <.up.> binance
        c2 <.up.> pyth
        cn <.up.> n
    }
}

ofw <.left.> papi : get price

cloud {
    node "Price-Source 1 - Binance" as binance {
    }
}

cloud {
    node "Price-Source 2 - Pyth" as pyth {
    }
}

cloud {
    node ".. Price-Source n" as n {
    }
}

"Oracle Provider" as op
op -up-> as
----

NOTE: It is proposed to rename the existing pallet-oracle as pallet-apollo here.

The following sections drill down into these components and others in more detail.

=== Component: Pallet Apollo
==== Data Structure: Price

[plantuml,images/price,png]
----
class Price {
    /// value
	price: PriceValue,
	block: BlockNumber,
}
----

==== Data Structure: PrePrice

[plantuml,images/pre-price,png]
----
class PrePrice {
    // The price of an asset, normalized to 12 decimals.
    price: PriceValue,
    // The block the price was submitted at.
    block: BlockNumber,
    // The account that submitted the price.
    who: AccountId,
}
----

==== Data Structure: AssetInfo

[plantuml,images/asset-info,png]
----
class AssetInfo {
    threshold: Percent,
    min_answers: u32,
    max_answers: u32,
    block_interval: BlockNumber,
    // Reward allocation weight for this asset
    // type out of the total block reward.
    reward_weight: Balance,
    slash: Balance,
}
----

==== Storage: AssetsInfo

----
asset_info = Map<AssetId, AssetInfo>
----

==== Storage: Prices

----
prices = Map<AssetId, Price>
----

==== Storage: PrePrices

----
pre_prices = Map<AssetId, Array<PrePrice>>
----

==== Storage: PriceHistory

----
price_history = Map<AssetId, Array<Price>>
----

==== Storage: OracleStake

----
oracle_stake = Map<AccountId, Balance>
----

==== Storage: RewardTrackerStore

For further details refer https://github.com/ComposableFi/composable/blob/main/frame/oracle/design/rewards/rewards-design.md[rewards-design].

==== Interface: Oracle

===== get_price

[source,rust]
----
fn get_price(asset_id: Self::AssetId, amount: Self::Balance, ) -> Result<Price<Self::Balance, Self::Timestamp>, DispatchError>;
----

TODO: Algo

===== get_twap_for_amount

[source,rust]
----
fn get_twap_for_amount(asset_id: Self::AssetId, amount: Self::Balance) -> Result<Self::Balance, DispatchError>;
----

TODO: Algo

===== get_ratio

[source,rust]
----
fn get_ratio(pair: composable_traits::defi::CurrencyPair<Self::AssetId>) -> Result<sp_runtime::FixedU128, DispatchError>;
----
TODO: Algo

===== get_price_inverse

[source,rust]
----
fn get_price_inverse(asset_id: Self::AssetId, amount: Self::Balance) -> Result<Self::Balance, DispatchError>;
----

TODO: Algo

==== Interface: Pallet Extrinsics

===== add_asset_and_info

[source,rust]
----
pub fn add_asset_and_info(
			origin: OriginFor<T>,
			asset_id: T::AssetId,
			threshold: Validated<Percent, ValidThreshhold>,
			min_answers: Validated<u32, ValidMinAnswers>,
			max_answers: Validated<u32, ValidMaxAnswer<T::MaxAnswerBound>>,
			block_interval: Validated<T::BlockNumber, ValidBlockInterval<T::StalePrice>>,
			reward_weight: BalanceOf<T>,
			slash: BalanceOf<T>,
		) -> DispatchResultWithPostInfo;
----

TODO: Algo

===== set_signer

[source,rust]
----
pub fn set_signer(
			origin: OriginFor<T>,
			signer: T::AccountId,
		) -> DispatchResultWithPostInfo;
----

TODO: Algo

===== adjust_rewards

[source,rust]
----
pub fn adjust_rewards(
			origin: OriginFor<T>,
			annual_cost_per_oracle: BalanceOf<T>,
			num_ideal_oracles: u8,
		) -> DispatchResultWithPostInfo;
----

TODO: Algo

===== add_stake

[source,rust]
----
pub fn add_stake(origin: OriginFor<T>, stake: BalanceOf<T>) -> DispatchResultWithPostInfo;
----

TODO: Algo

===== remove_stake

[source,rust]
----
pub fn remove_stake(origin: OriginFor<T>) -> DispatchResultWithPostInfo;
----

TODO: Algo

===== reclaim_stake

[source,rust]
----
pub fn reclaim_stake(origin: OriginFor<T>) -> DispatchResultWithPostInfo;
----

TODO: Algo

===== submit_price

[source,rust]
----
pub fn submit_price(
			origin: OriginFor<T>,
			price: T::PriceValue,
			asset_id: T::AssetId,
		) -> DispatchResultWithPostInfo;
----

TODO: Algo

==== Algorithm: Offchain Worker

.Offchain Worker: check_requests
[plantuml,images/offchain-worker,png]
----
start
while (asset_id, asset_info = AssetsInfo.iter().next())
  if (1. is_requested(asset_id)) then (yes)
    :2. fetch_price_and_send_signed(asset_id, asset_info);
  endif
endwhile
stop
----

Following are the sub-procedures from above main algorithm,

.Offchain Worker: is_requested
[plantuml,images/offchain-worker-1-is-requested,png]
----
start
->asset_id;
:last_update = prices[asset_id];
:asset_info = asset_info[asset_id];
if (exists asset_info ?) then (yes)
    :return
    last_update.block
    + asset_info.block_interval
    < current_block;
    note left: Price is requested if\nthe last update is too old
    stop
else (no)
    :return false;
    stop
endif
----

.Offchain Worker: fetch_price_and_send_signed
[plantuml,images/offchain-worker-2-fetch-price-and-send-signed,png]
----
start
->asset_id, asset_info;
:signer = all available keys in key_store;
:oracle_account_id = read_key_store();
:asset_info = asset_info[asset_id];
:prices = pre_prices[asset_id];
if (signer can not sign)
    :Error: No Local accounts to sign;
elseif (length of prices > asset_info.max_answers) then (yes)
    :Error: Maximum number of answers provided;
    stop
elseif (prices has price with\nwho=oracle_account_id) then (yes)
    :Error: Price already submitted by the Oracle;
    stop
else
    :price = fetch_price(asset_id);
    note right: Fetch price from the\nlocal price feed server
    :signed_extrinsic = sign with signer:
    extrinsic submit_price(asset_id, price);
    :call signed_extrinsic;
endif
stop
----

==== Algorithm: on_init Hook

- slashing - answer in transit?

=== Component: Price Feed Server

==== Interface: Price Feed Client

==== Interface: Rest API

=== Security and Price Accuracy Model

TODO

- Manipulation range without getting slashed?
- How much of bribe it takes for an Oracle provider to provide the wrong price?
- Chance of collusion
- Nothing at stake?
- Ensuring continuous function?

=== Becoming an Oracle Provider

==== Key Management

== Rollout

== References

. Distributed Blockchain Price Oracle. https://hal.archives-ouvertes.fr/hal-03620931/document
. Chainlink 2.0: Next Steps in the Evolution of Decentralized Oracle Networks. https://research.chain.link/whitepaper-v2.pdf
. Apollo docs. https://docs.composable.finance/products/the-picasso-parachain/the-picasso-tech-stack/apollo
