# XCM

XCM compatible chains providing liquidation engine functionality are called through XCM [Transact](https://github.com/paritytech/polkadot/blob/ed480c518b968b41172a99b6ebda5939f04f667e/xcm/src/v2/mod.rs#L308). The exact flow as well as the embedded Call are described here.

### Pallet-Liquidator

Liquidation-engines embed a pallet which exposes the following two extrinsics (or more accurately, they will receive a Call which decodes to the Call generated by pallet-liquidator, they are free to change the actual implementor).


```plain
type Config trait {
    type Handler: Liquidator
    type XCM: XCM,
}


impl Pallet<T: Config> {
    #[transactional]
    fn liquidate(origin: OriginFor<T>, id, assets, minimum_price) -> DispatchResultWithPostInfo {
       ensure_root!(origin)?;
       let result = T::Handler::liquidate(id, assets, minimum_price)?;
       XCM::call(return_location, InitialAck(result))?;
    }


    fn complete(origin: OriginFor<T>, id, amount_taken, final_price) -> DispatchResultWithPostInfo {
        ensure_root!(origin)?;
        XCM::call(return_location, FinalAck(id, amount_taken, final_price))?;
    }
```


`liquidate` is transmitted in the first Transact call.

`complete` should be called by the liquidation-engine (can be a trait method too).


Liquidation-engines capable of completing the liquidation instantly may omit sending `EstimatedCompletion`, and instead transmit `ActualCompletion`, immediately. If `ActualCompletion`, arrives before `EstimatedCompletion`, the latter will be discarded by Angular.
