{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Array_of_OrderItem",
  "type": "array",
  "items": {
    "$ref": "#/definitions/OrderItem"
  },
  "definitions": {
    "Addr": {
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "OrderItem": {
      "type": "object",
      "required": [
        "given",
        "msg",
        "order_id",
        "owner"
      ],
      "properties": {
        "given": {
          "$ref": "#/definitions/Coin"
        },
        "msg": {
          "$ref": "#/definitions/OrderSubMsg"
        },
        "order_id": {
          "$ref": "#/definitions/Uint128"
        },
        "owner": {
          "$ref": "#/definitions/Addr"
        }
      },
      "additionalProperties": false
    },
    "OrderSubMsg": {
      "type": "object",
      "required": [
        "timeout",
        "wants"
      ],
      "properties": {
        "min_fill": {
          "description": "if ok with partial fill, what is the minimum amount",
          "type": [
            "array",
            "null"
          ],
          "items": [
            {
              "$ref": "#/definitions/Uint64"
            },
            {
              "$ref": "#/definitions/Uint64"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        },
        "timeout": {
          "description": "how much blocks to wait for solution, if none, then cleaned up",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "transfer": {
          "description": "How offchain SDK must work with it? ```example Alice gives token 42 on this(settlement chain). But she wants token 123 on other chain. SDK reads all CVM configurations. And tells Alice that there are 2 routes of asset 123 to/from settlement chain. These routes are 666 and 777. Each asset has unique route to settlement chain in CVM configuration. Alice picks route 777. So SDK sends 42 token as given to  and 777 as wanted, but additionally with attached transfer route Alice picked. ``` This allow to to CoWs for assets not on this chain.",
          "anyOf": [
            {
              "$ref": "#/definitions/TransferRoute"
            },
            {
              "type": "null"
            }
          ]
        },
        "wants": {
          "description": "Amount is minimum amount to get for given amount (sure user wants more than `wants` and we try to achieve that). Denom users wants to get, it can be cw20, bank or this chain CVM asset identifier. Only local CVM identifiers are accepted. If target asset identifier on other chain, use `transfer` to identity it. Why this is the case? It allows to CoW with user wanted assets which is not on settlement(this) chain.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Spawn_for_TransferRoute": {
      "description": "Abstracted out route of underlying encoding on specific transport. In the end of route, amount is always put onto user CVM executor.",
      "type": "object",
      "required": [
        "carry",
        "to_chain"
      ],
      "properties": {
        "carry": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "execute": {
          "anyOf": [
            {
              "$ref": "#/definitions/TransferRoute"
            },
            {
              "type": "null"
            }
          ]
        },
        "to_chain": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "TransferRoute": {
      "description": "Purely transfer route.",
      "type": "object",
      "required": [
        "spawn"
      ],
      "properties": {
        "spawn": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Spawn_for_TransferRoute"
          }
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "Uint64": {
      "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
      "type": "string"
    }
  }
}
