{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Array_of_SolutionItem",
  "type": "array",
  "items": {
    "$ref": "#/definitions/SolutionItem"
  },
  "definitions": {
    "Cow": {
      "description": "how much of order to be solved by CoW. difference with `Fill` to be solved by cross chain exchange aggregate pool of all orders in solution is used to give user amount he wants.",
      "type": "object",
      "required": [
        "cow_amount",
        "given",
        "order_id"
      ],
      "properties": {
        "cow_amount": {
          "description": "how much of order to be solved by from bank for all aggregated cows",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "given": {
          "description": "amount user should get after order executed",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "order_id": {
          "$ref": "#/definitions/Uint128"
        },
        "taken": {
          "description": "amount of order to be taken (100% in case of full fill, can be less in case of partial)",
          "anyOf": [
            {
              "$ref": "#/definitions/Uint128"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Exchange": {
      "type": "object",
      "required": [
        "give",
        "pool_id",
        "want_min"
      ],
      "properties": {
        "give": {
          "$ref": "#/definitions/Uint128"
        },
        "pool_id": {
          "$ref": "#/definitions/Uint128"
        },
        "want_min": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false
    },
    "ExchangeRoute": {
      "description": "Route which may spawn on the way.",
      "type": "object",
      "required": [
        "exchange",
        "spawn"
      ],
      "properties": {
        "exchange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Exchange"
          }
        },
        "spawn": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Spawn_for_ExchangeRoute"
          }
        }
      },
      "additionalProperties": false
    },
    "SolutionItem": {
      "type": "object",
      "required": [
        "block_added",
        "msg",
        "pair"
      ],
      "properties": {
        "block_added": {
          "description": "at which block solution was added",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "msg": {
          "$ref": "#/definitions/SolutionSubMsg"
        },
        "pair": {
          "type": "array",
          "items": [
            {
              "type": "string"
            },
            {
              "type": "string"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "additionalProperties": false
    },
    "SolutionSubMsg": {
      "description": "price information will not be used on chain or deciding. it will fill orders on chain as instructed and check that max/min from orders respected and sum all into volume. and compare solutions. on chain cares each user gets what it wants and largest volume solution selected.",
      "type": "object",
      "required": [
        "timeout"
      ],
      "properties": {
        "cows": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Cow"
          }
        },
        "routes": {
          "description": "must adhere Connection.fork_join_supported, for now it is always false (it restrict set of routes possible)",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExchangeRoute"
          }
        },
        "timeout": {
          "description": "after some time, solver will not commit to success",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "Spawn_for_ExchangeRoute": {
      "description": "Abstracted out route of underlying encoding on specific transport. In the end of route, amount is always put onto user CVM executor.",
      "type": "object",
      "required": [
        "carry",
        "to_chain"
      ],
      "properties": {
        "carry": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "execute": {
          "anyOf": [
            {
              "$ref": "#/definitions/ExchangeRoute"
            },
            {
              "type": "null"
            }
          ]
        },
        "to_chain": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    }
  }
}
