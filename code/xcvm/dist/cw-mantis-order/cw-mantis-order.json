{
  "contract_name": "cw-mantis-order",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object"
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "order"
        ],
        "properties": {
          "order": {
            "type": "object",
            "required": [
              "msg"
            ],
            "properties": {
              "msg": {
                "$ref": "#/definitions/OrderSubMsg"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "route"
        ],
        "properties": {
          "route": {
            "type": "object",
            "required": [
              "_msg"
            ],
            "properties": {
              "_msg": {
                "$ref": "#/definitions/RouteSubMsg"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "solve"
        ],
        "properties": {
          "solve": {
            "type": "object",
            "required": [
              "msg"
            ],
            "properties": {
              "msg": {
                "$ref": "#/definitions/SolutionSubMsg"
              }
            }
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Cow": {
        "description": "how much of order to be solved by CoW. difference with `Fill` to be solved by cross chain exchange aggregate pool of all orders in solution is used to give user amount he wants.",
        "type": "object",
        "required": [
          "cow_amount",
          "given",
          "order_id"
        ],
        "properties": {
          "cow_amount": {
            "description": "how much of order to be solved by from bank for all aggregated cows",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "given": {
            "description": "amount user should get after order executed",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "order_id": {
            "$ref": "#/definitions/Uint128"
          },
          "taken": {
            "description": "amount of order to be taken (100% in case of full fill, can be less in case of partial)",
            "anyOf": [
              {
                "$ref": "#/definitions/Uint128"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Exchange": {
        "type": "object",
        "required": [
          "give",
          "pool_id",
          "want_min"
        ],
        "properties": {
          "give": {
            "$ref": "#/definitions/Uint128"
          },
          "pool_id": {
            "$ref": "#/definitions/Uint128"
          },
          "want_min": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "ExchangeRoute": {
        "description": "Route which may spawn on the way.",
        "type": "object",
        "required": [
          "exchange",
          "spawn"
        ],
        "properties": {
          "exchange": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Exchange"
            }
          },
          "spawn": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Spawn_for_ExchangeRoute"
            }
          }
        },
        "additionalProperties": false
      },
      "OrderItem": {
        "type": "object",
        "required": [
          "given",
          "msg",
          "order_id",
          "owner"
        ],
        "properties": {
          "given": {
            "$ref": "#/definitions/Coin"
          },
          "msg": {
            "$ref": "#/definitions/OrderSubMsg"
          },
          "order_id": {
            "$ref": "#/definitions/Uint128"
          },
          "owner": {
            "$ref": "#/definitions/Addr"
          }
        },
        "additionalProperties": false
      },
      "OrderSubMsg": {
        "type": "object",
        "required": [
          "timeout",
          "wants"
        ],
        "properties": {
          "min_fill": {
            "description": "if ok with partial fill, what is the minimum amount",
            "type": [
              "array",
              "null"
            ],
            "items": [
              {
                "$ref": "#/definitions/Uint64"
              },
              {
                "$ref": "#/definitions/Uint64"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          },
          "timeout": {
            "description": "how much blocks to wait for solution, if none, then cleaned up",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "transfer": {
            "description": "How offchain SDK must work with it? ```example Alice gives token 42 on this(settlement chain). But she wants token 123 on other chain. SDK reads all CVM configurations. And tells Alice that there are 2 routes of asset 123 to/from settlement chain. These routes are 666 and 777. Each asset has unique route to settlement chain in CVM configuration. Alice picks route 777. So SDK sends 42 token as given to  and 777 as wanted, but additionally with attached transfer route Alice picked. ``` This allow to to CoWs for assets not on this chain.",
            "anyOf": [
              {
                "$ref": "#/definitions/TransferRoute"
              },
              {
                "type": "null"
              }
            ]
          },
          "wants": {
            "description": "Amount is minimum amount to get for given amount (sure user wants more than `wants` and we try to achieve that). Denom users wants to get, it can be cw20, bank or this chain CVM asset identifier. Only local CVM identifiers are accepted. If target asset identifier on other chain, use `transfer` to identity it. Why this is the case? It allows to CoW with user wanted assets which is not on settlement(this) chain.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "RouteSubMsg": {
        "description": "after cows solved, need to route remaining cross chain",
        "type": "object",
        "required": [
          "all_orders",
          "routes"
        ],
        "properties": {
          "all_orders": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/SolvedOrder"
            }
          },
          "routes": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/ExchangeRoute"
            }
          }
        },
        "additionalProperties": false
      },
      "SolutionSubMsg": {
        "description": "price information will not be used on chain or deciding. it will fill orders on chain as instructed and check that max/min from orders respected and sum all into volume. and compare solutions. on chain cares each user gets what it wants and largest volume solution selected.",
        "type": "object",
        "required": [
          "timeout"
        ],
        "properties": {
          "cows": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Cow"
            }
          },
          "routes": {
            "description": "must adhere Connection.fork_join_supported, for now it is always false (it restrict set of routes possible)",
            "type": "array",
            "items": {
              "$ref": "#/definitions/ExchangeRoute"
            }
          },
          "timeout": {
            "description": "after some time, solver will not commit to success",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "SolvedOrder": {
        "type": "object",
        "required": [
          "order",
          "solution"
        ],
        "properties": {
          "order": {
            "$ref": "#/definitions/OrderItem"
          },
          "solution": {
            "$ref": "#/definitions/Cow"
          }
        },
        "additionalProperties": false
      },
      "Spawn_for_ExchangeRoute": {
        "description": "Abstracted out route of underlying encoding on specific transport. In the end of route, amount is always put onto user CVM executor.",
        "type": "object",
        "required": [
          "carry",
          "to_chain"
        ],
        "properties": {
          "carry": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "execute": {
            "anyOf": [
              {
                "$ref": "#/definitions/ExchangeRoute"
              },
              {
                "type": "null"
              }
            ]
          },
          "to_chain": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Spawn_for_TransferRoute": {
        "description": "Abstracted out route of underlying encoding on specific transport. In the end of route, amount is always put onto user CVM executor.",
        "type": "object",
        "required": [
          "carry",
          "to_chain"
        ],
        "properties": {
          "carry": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "execute": {
            "anyOf": [
              {
                "$ref": "#/definitions/TransferRoute"
              },
              {
                "type": "null"
              }
            ]
          },
          "to_chain": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "TransferRoute": {
        "description": "Purely transfer route.",
        "type": "object",
        "required": [
          "spawn"
        ],
        "properties": {
          "spawn": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Spawn_for_TransferRoute"
            }
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "get_all_orders"
        ],
        "properties": {
          "get_all_orders": {
            "type": "object"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_all_solutions"
        ],
        "properties": {
          "get_all_solutions": {
            "type": "object"
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "get_all_orders": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_OrderItem",
      "type": "array",
      "items": {
        "$ref": "#/definitions/OrderItem"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "OrderItem": {
          "type": "object",
          "required": [
            "given",
            "msg",
            "order_id",
            "owner"
          ],
          "properties": {
            "given": {
              "$ref": "#/definitions/Coin"
            },
            "msg": {
              "$ref": "#/definitions/OrderSubMsg"
            },
            "order_id": {
              "$ref": "#/definitions/Uint128"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            }
          },
          "additionalProperties": false
        },
        "OrderSubMsg": {
          "type": "object",
          "required": [
            "timeout",
            "wants"
          ],
          "properties": {
            "min_fill": {
              "description": "if ok with partial fill, what is the minimum amount",
              "type": [
                "array",
                "null"
              ],
              "items": [
                {
                  "$ref": "#/definitions/Uint64"
                },
                {
                  "$ref": "#/definitions/Uint64"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "timeout": {
              "description": "how much blocks to wait for solution, if none, then cleaned up",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "transfer": {
              "description": "How offchain SDK must work with it? ```example Alice gives token 42 on this(settlement chain). But she wants token 123 on other chain. SDK reads all CVM configurations. And tells Alice that there are 2 routes of asset 123 to/from settlement chain. These routes are 666 and 777. Each asset has unique route to settlement chain in CVM configuration. Alice picks route 777. So SDK sends 42 token as given to  and 777 as wanted, but additionally with attached transfer route Alice picked. ``` This allow to to CoWs for assets not on this chain.",
              "anyOf": [
                {
                  "$ref": "#/definitions/TransferRoute"
                },
                {
                  "type": "null"
                }
              ]
            },
            "wants": {
              "description": "Amount is minimum amount to get for given amount (sure user wants more than `wants` and we try to achieve that). Denom users wants to get, it can be cw20, bank or this chain CVM asset identifier. Only local CVM identifiers are accepted. If target asset identifier on other chain, use `transfer` to identity it. Why this is the case? It allows to CoW with user wanted assets which is not on settlement(this) chain.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Spawn_for_TransferRoute": {
          "description": "Abstracted out route of underlying encoding on specific transport. In the end of route, amount is always put onto user CVM executor.",
          "type": "object",
          "required": [
            "carry",
            "to_chain"
          ],
          "properties": {
            "carry": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "execute": {
              "anyOf": [
                {
                  "$ref": "#/definitions/TransferRoute"
                },
                {
                  "type": "null"
                }
              ]
            },
            "to_chain": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "TransferRoute": {
          "description": "Purely transfer route.",
          "type": "object",
          "required": [
            "spawn"
          ],
          "properties": {
            "spawn": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Spawn_for_TransferRoute"
              }
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_all_solutions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_SolutionItem",
      "type": "array",
      "items": {
        "$ref": "#/definitions/SolutionItem"
      },
      "definitions": {
        "Cow": {
          "description": "how much of order to be solved by CoW. difference with `Fill` to be solved by cross chain exchange aggregate pool of all orders in solution is used to give user amount he wants.",
          "type": "object",
          "required": [
            "cow_amount",
            "given",
            "order_id"
          ],
          "properties": {
            "cow_amount": {
              "description": "how much of order to be solved by from bank for all aggregated cows",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "given": {
              "description": "amount user should get after order executed",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "order_id": {
              "$ref": "#/definitions/Uint128"
            },
            "taken": {
              "description": "amount of order to be taken (100% in case of full fill, can be less in case of partial)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Uint128"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Exchange": {
          "type": "object",
          "required": [
            "give",
            "pool_id",
            "want_min"
          ],
          "properties": {
            "give": {
              "$ref": "#/definitions/Uint128"
            },
            "pool_id": {
              "$ref": "#/definitions/Uint128"
            },
            "want_min": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "ExchangeRoute": {
          "description": "Route which may spawn on the way.",
          "type": "object",
          "required": [
            "exchange",
            "spawn"
          ],
          "properties": {
            "exchange": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Exchange"
              }
            },
            "spawn": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Spawn_for_ExchangeRoute"
              }
            }
          },
          "additionalProperties": false
        },
        "SolutionItem": {
          "type": "object",
          "required": [
            "block_added",
            "msg",
            "pair"
          ],
          "properties": {
            "block_added": {
              "description": "at which block solution was added",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "msg": {
              "$ref": "#/definitions/SolutionSubMsg"
            },
            "pair": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            }
          },
          "additionalProperties": false
        },
        "SolutionSubMsg": {
          "description": "price information will not be used on chain or deciding. it will fill orders on chain as instructed and check that max/min from orders respected and sum all into volume. and compare solutions. on chain cares each user gets what it wants and largest volume solution selected.",
          "type": "object",
          "required": [
            "timeout"
          ],
          "properties": {
            "cows": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Cow"
              }
            },
            "routes": {
              "description": "must adhere Connection.fork_join_supported, for now it is always false (it restrict set of routes possible)",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ExchangeRoute"
              }
            },
            "timeout": {
              "description": "after some time, solver will not commit to success",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Spawn_for_ExchangeRoute": {
          "description": "Abstracted out route of underlying encoding on specific transport. In the end of route, amount is always put onto user CVM executor.",
          "type": "object",
          "required": [
            "carry",
            "to_chain"
          ],
          "properties": {
            "carry": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "execute": {
              "anyOf": [
                {
                  "$ref": "#/definitions/ExchangeRoute"
                },
                {
                  "type": "null"
                }
              ]
            },
            "to_chain": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
