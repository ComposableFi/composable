/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, Addr, NetworkId, HereItem, ExecuteMsg, ConfigSubMsg, Prefix, GatewayId, XPrefixedHexString, IbcIcs20Sender, RelativeTimeout, ChannelId, ConnectionId, AssetId, DisplayedForUint128, ForeignAssetId, AssetReference, ExchangeType, FundsForDisplayedForUint128, InstructionForArrayOfUint8AndXcAddrAndFundsForBalance, DisplayedForUint64, FundsForBalance, DestinationForXcAddr, XcAddr, CanonicalAddr, Binary, BindingValue, Register, CallOrigin, UserId, ShortcutSubMsg, Uint128, NetworkItem, IbcEnabled, IbcChannels, Ics20Channel, Ics20Features, Adr08IbcCallbacks, PFM, OsmosisIbcHooks, ForceNetworkToNetworkMsg, OtherNetworkItem, IcsPair, ChannelInfo, IbcEndpoint, AssetItem, BridgeAsset, PrefixedDenom, ExchangeItem, SwapAmountInRoute, ExecuteProgramMsg, ProgramForArrayOfInstructionForArrayOfUint8AndXcAddrAndFundsForBalance, Balance, Amount, UserOrigin, BridgeForwardMsg, InterpreterOrigin, XcMessageData, PacketForProgramForArrayOfInstructionForArrayOfUint8AndXcAddrAndFundsForBalance, QueryMsg, GetAssetResponse, GetExchangeResponse, GetIbcIcs20RouteResponse, IbcIcs20ProgramRoute } from "./CwMantisOrder.types";
export interface CwMantisOrderReadOnlyInterface {
  contractAddress: string;
  getAssetById: ({
    assetId
  }: {
    assetId: AssetId;
  }) => Promise<GetAssetResponse>;
  getLocalAssetByReference: ({
    reference
  }: {
    reference: AssetReference;
  }) => Promise<GetAssetResponse>;
  getIbcIcs20Route: ({
    forAsset,
    toNetwork
  }: {
    forAsset: AssetId;
    toNetwork: NetworkId;
  }) => Promise<GetIbcIcs20RouteResponse>;
  getExchangeById: ({
    exchangeId
  }: {
    exchangeId: Displayed_for_uint128;
  }) => Promise<GetExchangeResponse>;
}
export class CwMantisOrderQueryClient implements CwMantisOrderReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getAssetById = this.getAssetById.bind(this);
    this.getLocalAssetByReference = this.getLocalAssetByReference.bind(this);
    this.getIbcIcs20Route = this.getIbcIcs20Route.bind(this);
    this.getExchangeById = this.getExchangeById.bind(this);
  }

  getAssetById = async ({
    assetId
  }: {
    assetId: AssetId;
  }): Promise<GetAssetResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_asset_by_id: {
        asset_id: assetId
      }
    });
  };
  getLocalAssetByReference = async ({
    reference
  }: {
    reference: AssetReference;
  }): Promise<GetAssetResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_local_asset_by_reference: {
        reference
      }
    });
  };
  getIbcIcs20Route = async ({
    forAsset,
    toNetwork
  }: {
    forAsset: AssetId;
    toNetwork: NetworkId;
  }): Promise<GetIbcIcs20RouteResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_ibc_ics20_route: {
        for_asset: forAsset,
        to_network: toNetwork
      }
    });
  };
  getExchangeById = async ({
    exchangeId
  }: {
    exchangeId: Displayed_for_uint128;
  }): Promise<GetExchangeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_exchange_by_id: {
        exchange_id: exchangeId
      }
    });
  };
}
export interface CwMantisOrderInterface extends CwMantisOrderReadOnlyInterface {
  contractAddress: string;
  sender: string;
  config: (configSubMsg: ConfigSubMsg, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  executeProgram: ({
    executeProgram,
    tip
  }: {
    executeProgram: ExecuteProgramMsg;
    tip: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  executeProgramPrivileged: ({
    callOrigin,
    executeProgram,
    tip
  }: {
    callOrigin: CallOrigin;
    executeProgram: ExecuteProgramMsg;
    tip: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bridgeForward: ({
    interpreterOrigin,
    msg,
    to
  }: {
    interpreterOrigin: InterpreterOrigin;
    msg: ExecuteProgramMsg;
    to: NetworkId;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  shortcut: (shortcutSubMsg: ShortcutSubMsg, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  messageHook: ({
    fromNetworkId,
    packet
  }: {
    fromNetworkId: NetworkId;
    packet: PacketForProgramForArrayOfInstructionForArray_of_uint8AndXcAddrAndFundsForBalance;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class CwMantisOrderClient extends CwMantisOrderQueryClient implements CwMantisOrderInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.executeProgram = this.executeProgram.bind(this);
    this.executeProgramPrivileged = this.executeProgramPrivileged.bind(this);
    this.bridgeForward = this.bridgeForward.bind(this);
    this.shortcut = this.shortcut.bind(this);
    this.messageHook = this.messageHook.bind(this);
  }

  config = async (configSubMsg: ConfigSubMsg, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      config: configSubMsg
    }, fee, memo, _funds);
  };
  executeProgram = async ({
    executeProgram,
    tip
  }: {
    executeProgram: ExecuteProgramMsg;
    tip: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      execute_program: {
        execute_program: executeProgram,
        tip
      }
    }, fee, memo, _funds);
  };
  executeProgramPrivileged = async ({
    callOrigin,
    executeProgram,
    tip
  }: {
    callOrigin: CallOrigin;
    executeProgram: ExecuteProgramMsg;
    tip: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      execute_program_privileged: {
        call_origin: callOrigin,
        execute_program: executeProgram,
        tip
      }
    }, fee, memo, _funds);
  };
  bridgeForward = async ({
    interpreterOrigin,
    msg,
    to
  }: {
    interpreterOrigin: InterpreterOrigin;
    msg: ExecuteProgramMsg;
    to: NetworkId;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bridge_forward: {
        interpreter_origin: interpreterOrigin,
        msg,
        to
      }
    }, fee, memo, _funds);
  };
  shortcut = async (shortcutSubMsg: ShortcutSubMsg, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      shortcut: shortcutSubMsg
    }, fee, memo, _funds);
  };
  messageHook = async ({
    fromNetworkId,
    packet
  }: {
    fromNetworkId: NetworkId;
    packet: PacketForProgramForArrayOfInstructionForArray_of_uint8AndXcAddrAndFundsForBalance;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      message_hook: {
        from_network_id: fromNetworkId,
        packet
      }
    }, fee, memo, _funds);
  };
}