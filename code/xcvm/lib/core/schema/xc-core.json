{
  "contract_name": "xc-core",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "allOf": [
      {
        "$ref": "#/definitions/HereItem"
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "HereItem": {
        "type": "object",
        "required": [
          "admin",
          "here_id"
        ],
        "properties": {
          "admin": {
            "description": "The admin which is allowed to update the bridge list.",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          },
          "here_id": {
            "description": "Network ID of this network",
            "allOf": [
              {
                "$ref": "#/definitions/NetworkId"
              }
            ]
          }
        }
      },
      "NetworkId": {
        "description": "Newtype for XCVM networks ID. Must be unique for each network and must never change. This ID is an opaque, arbitrary type from the XCVM protocol and no assumption must be made on how it is computed.",
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/definitions/ConfigSubMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sent by the user to execute a program on their behalf.",
        "type": "object",
        "required": [
          "execute_program"
        ],
        "properties": {
          "execute_program": {
            "type": "object",
            "required": [
              "execute_program",
              "tip"
            ],
            "properties": {
              "execute_program": {
                "description": "Program to execute.",
                "allOf": [
                  {
                    "$ref": "#/definitions/ExecuteProgramMsg"
                  }
                ]
              },
              "tip": {
                "$ref": "#/definitions/Addr"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Request to execute a program on behalf of given user.\n\nThis can only be sent by trusted contract.  The message is",
        "type": "object",
        "required": [
          "execute_program_privileged"
        ],
        "properties": {
          "execute_program_privileged": {
            "type": "object",
            "required": [
              "call_origin",
              "execute_program",
              "tip"
            ],
            "properties": {
              "call_origin": {
                "description": "The origin of the call.",
                "allOf": [
                  {
                    "$ref": "#/definitions/CallOrigin"
                  }
                ]
              },
              "execute_program": {
                "description": "Program to execute.",
                "allOf": [
                  {
                    "$ref": "#/definitions/ExecuteProgramMsg"
                  }
                ]
              },
              "tip": {
                "$ref": "#/definitions/Addr"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Message sent from interpreter trying to spawn program on another network.",
        "type": "object",
        "required": [
          "bridge_forward"
        ],
        "properties": {
          "bridge_forward": {
            "$ref": "#/definitions/BridgeForwardMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "simple permissionless message which produce xcvm program to test routes",
        "type": "object",
        "required": [
          "shortcut"
        ],
        "properties": {
          "shortcut": {
            "$ref": "#/definitions/ShortcutSubMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "executed by host as part of memo handling",
        "type": "object",
        "required": [
          "message_hook"
        ],
        "properties": {
          "message_hook": {
            "$ref": "#/definitions/XcMessageData"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Amount": {
        "description": "See https://en.wikipedia.org/wiki/Linear_equation#Slope%E2%80%93intercept_form_or_Gradient-intercept_form",
        "type": "object",
        "required": [
          "intercept",
          "slope"
        ],
        "properties": {
          "intercept": {
            "$ref": "#/definitions/Displayed_for_uint128"
          },
          "slope": {
            "$ref": "#/definitions/Displayed_for_uint128"
          }
        }
      },
      "AssetId": {
        "description": "Newtype for XCVM assets ID. Must be unique for each asset and must never change. This ID is an opaque, arbitrary type from the XCVM protocol and no assumption must be made on how it is computed.",
        "allOf": [
          {
            "$ref": "#/definitions/Displayed_for_uint128"
          }
        ]
      },
      "AssetItem": {
        "type": "object",
        "required": [
          "asset_id",
          "from_network_id",
          "local"
        ],
        "properties": {
          "asset_id": {
            "$ref": "#/definitions/AssetId"
          },
          "bridged": {
            "anyOf": [
              {
                "$ref": "#/definitions/BridgeAsset"
              },
              {
                "type": "null"
              }
            ]
          },
          "from_network_id": {
            "$ref": "#/definitions/NetworkId"
          },
          "local": {
            "$ref": "#/definitions/AssetReference"
          }
        }
      },
      "AssetReference": {
        "description": "Definition of an asset on this local chain to operate with",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "a_d_r001"
            ],
            "properties": {
              "a_d_r001": {
                "type": "object",
                "required": [
                  "sha256"
                ],
                "properties": {
                  "sha256": {
                    "$ref": "#/definitions/HexBinary"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw20"
            ],
            "properties": {
              "cw20": {
                "type": "object",
                "required": [
                  "contract"
                ],
                "properties": {
                  "contract": {
                    "$ref": "#/definitions/Addr"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Balance": {
        "type": "object",
        "required": [
          "amount",
          "is_unit"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Amount"
          },
          "is_unit": {
            "type": "boolean"
          }
        }
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "BindingValue": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "register"
            ],
            "properties": {
              "register": {
                "$ref": "#/definitions/Register"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Asset's address",
            "type": "object",
            "required": [
              "asset"
            ],
            "properties": {
              "asset": {
                "$ref": "#/definitions/AssetId"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "asset_amount"
            ],
            "properties": {
              "asset_amount": {
                "type": "array",
                "items": [
                  {
                    "$ref": "#/definitions/AssetId"
                  },
                  {
                    "$ref": "#/definitions/Balance"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "BridgeAsset": {
        "type": "object",
        "required": [
          "location_on_network"
        ],
        "properties": {
          "location_on_network": {
            "$ref": "#/definitions/ForeignAssetId"
          }
        }
      },
      "BridgeForwardMsg": {
        "type": "object",
        "required": [
          "interpreter_origin",
          "msg",
          "to"
        ],
        "properties": {
          "interpreter_origin": {
            "$ref": "#/definitions/InterpreterOrigin"
          },
          "msg": {
            "$ref": "#/definitions/ExecuteProgramMsg"
          },
          "to": {
            "description": "target network",
            "allOf": [
              {
                "$ref": "#/definitions/NetworkId"
              }
            ]
          }
        }
      },
      "CallOrigin": {
        "description": "The Origin that executed the XCVM operation. Origin was verified to satisfy security semantics for execution.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "Remote"
            ],
            "properties": {
              "Remote": {
                "type": "object",
                "required": [
                  "user_origin"
                ],
                "properties": {
                  "user_origin": {
                    "$ref": "#/definitions/UserOrigin"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "Local"
            ],
            "properties": {
              "Local": {
                "type": "object",
                "required": [
                  "user"
                ],
                "properties": {
                  "user": {
                    "$ref": "#/definitions/Addr"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "CanonicalAddr": {
        "description": "A blockchain address in its binary form.\n\nThe specific implementation is up to the underlying chain and CosmWasm as well as contracts should not make assumptions on that data. In Ethereum for example, an `Addr` would contain a user visible address like 0x14d3cc818735723ab86eaf9502376e847a64ddad and the corresponding `CanonicalAddr` would store the 20 bytes 0x14, 0xD3, ..., 0xAD. In Cosmos, the bech32 format is used for `Addr`s and the `CanonicalAddr` holds the encoded bech32 data without the checksum. Typical sizes are 20 bytes for externally owned addresses and 32 bytes for module addresses (such as x/wasm contract addresses). That being said, a chain might decide to use any size other than 20 or 32 bytes.\n\nThe safe way to obtain a valid `CanonicalAddr` is using `Api::addr_canonicalize`. In addition to that there are many unsafe ways to convert any binary data into an instance. So the type shoud be treated as a marker to express the intended data type, not as a validity guarantee of any sort.",
        "allOf": [
          {
            "$ref": "#/definitions/Binary"
          }
        ]
      },
      "ChannelId": {
        "type": "string"
      },
      "ChannelInfo": {
        "description": "Information associated with an IBC channel.",
        "type": "object",
        "required": [
          "connection_id",
          "counterparty_endpoint",
          "id"
        ],
        "properties": {
          "connection_id": {
            "description": "the connection this exists on (you can use to query client/consensus info)",
            "allOf": [
              {
                "$ref": "#/definitions/ConnectionId"
              }
            ]
          },
          "counterparty_endpoint": {
            "description": "the remote channel/port we connect to",
            "allOf": [
              {
                "$ref": "#/definitions/IbcEndpoint"
              }
            ]
          },
          "id": {
            "description": "id of this channel",
            "allOf": [
              {
                "$ref": "#/definitions/ChannelId"
              }
            ]
          }
        }
      },
      "ConfigSubMsg": {
        "description": "cross cross chain routing requires a lot of configuration, about chain executing this contract, about connectivity to and of other chains (even if not connected directly) and about assets and services on these chains (in future block hooks and some set of host extensions/precompiles would help to get some info automatically) `Force` message sets the data unconditionally.",
        "oneOf": [
          {
            "description": "Permissioned message (gov or admin) to force set information about network contract is executed. Network can be any network or this network (so it overrides some this network parameters too)",
            "type": "object",
            "required": [
              "force_network"
            ],
            "properties": {
              "force_network": {
                "$ref": "#/definitions/NetworkItem"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets network to network connectivity/routing information",
            "type": "object",
            "required": [
              "force_network_to_network"
            ],
            "properties": {
              "force_network_to_network": {
                "$ref": "#/definitions/ForceNetworkToNetworkMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Permissioned message (gov or admin) to force set asset information.",
            "type": "object",
            "required": [
              "force_asset"
            ],
            "properties": {
              "force_asset": {
                "$ref": "#/definitions/AssetItem"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Message sent by an admin to remove an asset from registry.",
            "type": "object",
            "required": [
              "force_remove_asset"
            ],
            "properties": {
              "force_remove_asset": {
                "type": "object",
                "required": [
                  "asset_id"
                ],
                "properties": {
                  "asset_id": {
                    "$ref": "#/definitions/AssetId"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ConnectionId": {
        "type": "string"
      },
      "Destination_for_CanonicalAddr": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "tip"
            ]
          },
          {
            "type": "object",
            "required": [
              "account"
            ],
            "properties": {
              "account": {
                "$ref": "#/definitions/CanonicalAddr"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Displayed_for_uint128": {
        "description": "A wrapper around a type which is serde-serialised as a string.\n\nFor serde-serialisation to be implemented for the type `T` must implement `Display` and `FromStr` traits.\n\n``` # use xc_core::Displayed;\n\n#[derive(serde::Serialize, serde::Deserialize)] struct Foo { value: Displayed<u64> }\n\nlet encoded = serde_json_wasm::to_string(&Foo { value: Displayed(42) }).unwrap(); assert_eq!(r#\"{\"value\":\"42\"}\"#, encoded);\n\nlet decoded = serde_json_wasm::from_str::<Foo>(r#\"{\"value\":\"42\"}\"#).unwrap(); assert_eq!(Displayed(42), decoded.value); ```",
        "type": "integer",
        "format": "uint128",
        "minimum": 0.0
      },
      "ExecuteProgramMsg": {
        "description": "Definition of a program to be executed including its context.",
        "type": "object",
        "required": [
          "assets",
          "program",
          "salt"
        ],
        "properties": {
          "assets": {
            "description": "Assets to fund the XCVM interpreter instance The interpreter is funded prior to execution",
            "allOf": [
              {
                "$ref": "#/definitions/Funds_for_Displayed_for_uint128"
              }
            ]
          },
          "program": {
            "description": "The program.",
            "allOf": [
              {
                "$ref": "#/definitions/Program_for_Array_of_Instruction_for_Array_of_uint8_and_CanonicalAddr_and_Funds_for_Balance"
              }
            ]
          },
          "salt": {
            "description": "The program salt.",
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            }
          }
        }
      },
      "ForceNetworkToNetworkMsg": {
        "type": "object",
        "required": [
          "from",
          "other",
          "to"
        ],
        "properties": {
          "from": {
            "$ref": "#/definitions/NetworkId"
          },
          "other": {
            "description": "on `to` chain",
            "allOf": [
              {
                "$ref": "#/definitions/OtherNetworkItem"
              }
            ]
          },
          "to": {
            "$ref": "#/definitions/NetworkId"
          }
        }
      },
      "ForeignAssetId": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "ibc_ics20"
            ],
            "properties": {
              "ibc_ics20": {
                "$ref": "#/definitions/PrefixedDenom"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Funds_for_Balance": {
        "description": "a set of assets with non zero balances",
        "type": "array",
        "items": {
          "type": "array",
          "items": [
            {
              "$ref": "#/definitions/AssetId"
            },
            {
              "$ref": "#/definitions/Balance"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "Funds_for_Displayed_for_uint128": {
        "description": "a set of assets with non zero balances",
        "type": "array",
        "items": {
          "type": "array",
          "items": [
            {
              "$ref": "#/definitions/AssetId"
            },
            {
              "$ref": "#/definitions/Displayed_for_uint128"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "GatewayId": {
        "description": "when message is sent to other side, we should identify receiver of some kind",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "cosm_wasm"
            ],
            "properties": {
              "cosm_wasm": {
                "type": "object",
                "required": [
                  "admin",
                  "contract",
                  "interpreter_code_id"
                ],
                "properties": {
                  "admin": {
                    "description": "admin of everything",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Addr"
                      }
                    ]
                  },
                  "contract": {
                    "$ref": "#/definitions/Addr"
                  },
                  "interpreter_code_id": {
                    "description": "Address of the XCVM interpreter contract code",
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "HexBinary": {
        "description": "This is a wrapper around Vec<u8> to add hex de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is similar to `cosmwasm_std::Binary` but uses hex. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "IbcChannels": {
        "type": "object",
        "properties": {
          "ics20": {
            "anyOf": [
              {
                "$ref": "#/definitions/Ics20Channel"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "IbcEnabled": {
        "type": "object",
        "properties": {
          "channels": {
            "anyOf": [
              {
                "$ref": "#/definitions/IbcChannels"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "IbcEndpoint": {
        "type": "object",
        "required": [
          "channel_id",
          "port_id"
        ],
        "properties": {
          "channel_id": {
            "type": "string"
          },
          "port_id": {
            "type": "string"
          }
        }
      },
      "IbcIcs20Sender": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "CosmosStargateIbcApplicationsTransferV1MsgTransfer",
              "CosmWasmStd1_3"
            ]
          },
          {
            "type": "object",
            "required": [
              "SubstratePrecompile"
            ],
            "properties": {
              "SubstratePrecompile": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IbcTimeout": {
        "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
        "type": "object",
        "properties": {
          "block": {
            "anyOf": [
              {
                "$ref": "#/definitions/IbcTimeoutBlock"
              },
              {
                "type": "null"
              }
            ]
          },
          "timestamp": {
            "anyOf": [
              {
                "$ref": "#/definitions/Timestamp"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "IbcTimeoutBlock": {
        "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
        "type": "object",
        "required": [
          "height",
          "revision"
        ],
        "properties": {
          "height": {
            "description": "block height after which the packet times out. the height within the given revision",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "revision": {
            "description": "the version that the client is currently on (eg. after reseting the chain this could increment 1 as height drops to 0)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "Ics20Channel": {
        "type": "object",
        "required": [
          "sender"
        ],
        "properties": {
          "features": {
            "anyOf": [
              {
                "$ref": "#/definitions/Ics20Features"
              },
              {
                "type": "null"
              }
            ]
          },
          "sender": {
            "description": "specific per chain way to send IBC ICS 20 assets",
            "allOf": [
              {
                "$ref": "#/definitions/IbcIcs20Sender"
              }
            ]
          }
        }
      },
      "Ics20Features": {
        "description": "what features/modules/version enabled/installed/configured",
        "type": "object",
        "properties": {
          "pfm": {
            "anyOf": [
              {
                "$ref": "#/definitions/PFM"
              },
              {
                "type": "null"
              }
            ]
          },
          "wasm_hooks": {
            "description": "if it is exists, chain has that enabled",
            "anyOf": [
              {
                "$ref": "#/definitions/WasmHooks"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "IcsPair": {
        "description": "we need both, so we can unwrap",
        "type": "object",
        "required": [
          "sink",
          "source"
        ],
        "properties": {
          "sink": {
            "$ref": "#/definitions/ChannelId"
          },
          "source": {
            "$ref": "#/definitions/ChannelId"
          }
        }
      },
      "Instruction_for_Array_of_uint8_and_CanonicalAddr_and_Funds_for_Balance": {
        "description": "Base XCVM instructions. This set will remain as small as possible, expressiveness must come on `top` of the base instructions.",
        "oneOf": [
          {
            "description": "Transfer some [`Assets`] from the current program to the [`to`] account.",
            "type": "object",
            "required": [
              "transfer"
            ],
            "properties": {
              "transfer": {
                "type": "object",
                "required": [
                  "assets",
                  "to"
                ],
                "properties": {
                  "assets": {
                    "$ref": "#/definitions/Funds_for_Balance"
                  },
                  "to": {
                    "$ref": "#/definitions/Destination_for_CanonicalAddr"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Arbitrary payload representing a raw call inside the current network.\n\nOn picasso, this will be a SCALE encoded dispatch call. On ethereum, an ethereum ABI encoded call. On cosmos, a raw json WasmMsg call.\n\nDepending on the network, the payload might be more structured than the base call. For most of the network in fact, we need to provide the target address along the payload, which can be encoded inside this single payload.",
            "type": "object",
            "required": [
              "call"
            ],
            "properties": {
              "call": {
                "type": "object",
                "required": [
                  "bindings",
                  "encoded"
                ],
                "properties": {
                  "bindings": {
                    "type": "array",
                    "items": {
                      "type": "array",
                      "items": [
                        {
                          "type": "integer",
                          "format": "uint32",
                          "minimum": 0.0
                        },
                        {
                          "$ref": "#/definitions/BindingValue"
                        }
                      ],
                      "maxItems": 2,
                      "minItems": 2
                    }
                  },
                  "encoded": {
                    "type": "array",
                    "items": {
                      "type": "integer",
                      "format": "uint8",
                      "minimum": 0.0
                    }
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Spawn a sub-program on the target `network`.\n\nThe program will be spawned with the desired [`Assets`]. The salt is used to track the program when events are dispatched in the network.",
            "type": "object",
            "required": [
              "spawn"
            ],
            "properties": {
              "spawn": {
                "type": "object",
                "required": [
                  "assets",
                  "network",
                  "program",
                  "salt"
                ],
                "properties": {
                  "assets": {
                    "$ref": "#/definitions/Funds_for_Balance"
                  },
                  "network": {
                    "$ref": "#/definitions/NetworkId"
                  },
                  "program": {
                    "$ref": "#/definitions/Program_for_Array_of_Instruction_for_Array_of_uint8_and_CanonicalAddr_and_Funds_for_Balance"
                  },
                  "salt": {
                    "type": "array",
                    "items": {
                      "type": "integer",
                      "format": "uint8",
                      "minimum": 0.0
                    }
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "exchange"
            ],
            "properties": {
              "exchange": {
                "type": "object",
                "required": [
                  "give",
                  "id",
                  "want"
                ],
                "properties": {
                  "give": {
                    "$ref": "#/definitions/Funds_for_Balance"
                  },
                  "id": {
                    "type": "integer",
                    "format": "uint128",
                    "minimum": 0.0
                  },
                  "want": {
                    "$ref": "#/definitions/Funds_for_Balance"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "InterpreterOrigin": {
        "description": "The interpreter origin, composite of a user origin and a salt.",
        "type": "object",
        "required": [
          "salt",
          "user_origin"
        ],
        "properties": {
          "salt": {
            "type": "string"
          },
          "user_origin": {
            "$ref": "#/definitions/UserOrigin"
          }
        }
      },
      "NetworkId": {
        "description": "Newtype for XCVM networks ID. Must be unique for each network and must never change. This ID is an opaque, arbitrary type from the XCVM protocol and no assumption must be made on how it is computed.",
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "NetworkItem": {
        "type": "object",
        "required": [
          "network_id"
        ],
        "properties": {
          "accounts": {
            "description": "Account encoding type",
            "anyOf": [
              {
                "$ref": "#/definitions/Prefix"
              },
              {
                "type": "null"
              }
            ]
          },
          "gateway": {
            "description": "something which will be receiver on other side case of network has XCVM deployed as contract, account address is stored here",
            "anyOf": [
              {
                "$ref": "#/definitions/GatewayId"
              },
              {
                "type": "null"
              }
            ]
          },
          "ibc": {
            "anyOf": [
              {
                "$ref": "#/definitions/IbcEnabled"
              },
              {
                "type": "null"
              }
            ]
          },
          "network_id": {
            "$ref": "#/definitions/NetworkId"
          }
        }
      },
      "OtherNetworkItem": {
        "type": "object",
        "required": [
          "counterparty_timeout"
        ],
        "properties": {
          "counterparty_timeout": {
            "description": "default timeout to use for direct send",
            "allOf": [
              {
                "$ref": "#/definitions/IbcTimeout"
              }
            ]
          },
          "ics_20": {
            "anyOf": [
              {
                "$ref": "#/definitions/IcsPair"
              },
              {
                "type": "null"
              }
            ]
          },
          "xcvm_channel": {
            "description": "if there is custom IBC channel opened",
            "anyOf": [
              {
                "$ref": "#/definitions/ChannelInfo"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "PFM": {
        "type": "object"
      },
      "Prefix": {
        "description": "given prefix you may form accounts from 32 bit addresses or partially identify chains",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "s_s58"
            ],
            "properties": {
              "s_s58": {
                "type": "integer",
                "format": "uint16",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "bech"
            ],
            "properties": {
              "bech": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PrefixedDenom": {
        "description": "A type that contains the base denomination for ICS20 and the source tracing information path.",
        "type": "object",
        "required": [
          "base_denom",
          "trace_path"
        ],
        "properties": {
          "base_denom": {
            "description": "Base denomination of the relayed fungible token.",
            "type": "string"
          },
          "trace_path": {
            "description": "A series of `{port-id}/{channel-id}`s for tracing the source of the token.",
            "type": "string"
          }
        }
      },
      "Program_for_Array_of_Instruction_for_Array_of_uint8_and_CanonicalAddr_and_Funds_for_Balance": {
        "type": "object",
        "required": [
          "instructions",
          "tag"
        ],
        "properties": {
          "instructions": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Instruction_for_Array_of_uint8_and_CanonicalAddr_and_Funds_for_Balance"
            }
          },
          "tag": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            }
          }
        }
      },
      "Register": {
        "oneOf": [
          {
            "description": "Instruction pointer",
            "type": "string",
            "enum": [
              "ip"
            ]
          },
          {
            "description": "Tip's address",
            "type": "string",
            "enum": [
              "tip"
            ]
          },
          {
            "description": "Interpreter's address",
            "type": "string",
            "enum": [
              "this"
            ]
          },
          {
            "description": "Result of the last executed instruction",
            "type": "string",
            "enum": [
              "result"
            ]
          }
        ]
      },
      "ShortcutSubMsg": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "transfer"
            ],
            "properties": {
              "transfer": {
                "type": "object",
                "required": [
                  "amount",
                  "asset_id",
                  "network"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "asset_id": {
                    "description": "assets from there",
                    "allOf": [
                      {
                        "$ref": "#/definitions/AssetId"
                      }
                    ]
                  },
                  "network": {
                    "description": "target network, can hope over several networks if route is stored in state",
                    "allOf": [
                      {
                        "$ref": "#/definitions/NetworkId"
                      }
                    ]
                  },
                  "receiver": {
                    "description": "by default receiver is this",
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "UserId": {
        "description": "Arbitrary `User` type that represent the identity of a user on a given network, usually a public key.",
        "type": "string"
      },
      "UserOrigin": {
        "description": "The origin of a user, which consist of the composite, origin network and origin network user id.",
        "type": "object",
        "required": [
          "network_id",
          "user_id"
        ],
        "properties": {
          "network_id": {
            "$ref": "#/definitions/NetworkId"
          },
          "user_id": {
            "$ref": "#/definitions/UserId"
          }
        }
      },
      "WasmHooks": {
        "type": "object",
        "required": [
          "callback"
        ],
        "properties": {
          "callback": {
            "type": "boolean"
          }
        }
      },
      "XcMessageData": {
        "description": "This message should be send as part of wasm termination memo. So that can match it to sender hash and know what channel and origin was used to send message. All information here is not secured until compared with existing secured data.",
        "type": "object",
        "required": [
          "data",
          "from_network_id"
        ],
        "properties": {
          "data": {
            "$ref": "#/definitions/Binary"
          },
          "from_network_id": {
            "$ref": "#/definitions/NetworkId"
          }
        }
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Returns [`AssetReference`] for an asset with given id.",
        "type": "object",
        "required": [
          "lookup_asset"
        ],
        "properties": {
          "lookup_asset": {
            "type": "object",
            "required": [
              "asset_id"
            ],
            "properties": {
              "asset_id": {
                "$ref": "#/definitions/AssetId"
              }
            }
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AssetId": {
        "description": "Newtype for XCVM assets ID. Must be unique for each asset and must never change. This ID is an opaque, arbitrary type from the XCVM protocol and no assumption must be made on how it is computed.",
        "allOf": [
          {
            "$ref": "#/definitions/Displayed_for_uint128"
          }
        ]
      },
      "Displayed_for_uint128": {
        "description": "A wrapper around a type which is serde-serialised as a string.\n\nFor serde-serialisation to be implemented for the type `T` must implement `Display` and `FromStr` traits.\n\n``` # use xc_core::Displayed;\n\n#[derive(serde::Serialize, serde::Deserialize)] struct Foo { value: Displayed<u64> }\n\nlet encoded = serde_json_wasm::to_string(&Foo { value: Displayed(42) }).unwrap(); assert_eq!(r#\"{\"value\":\"42\"}\"#, encoded);\n\nlet decoded = serde_json_wasm::from_str::<Foo>(r#\"{\"value\":\"42\"}\"#).unwrap(); assert_eq!(Displayed(42), decoded.value); ```",
        "type": "integer",
        "format": "uint128",
        "minimum": 0.0
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "lookup_asset": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LookupResponse",
      "type": "object",
      "required": [
        "reference"
      ],
      "properties": {
        "reference": {
          "$ref": "#/definitions/AssetItem"
        }
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetId": {
          "description": "Newtype for XCVM assets ID. Must be unique for each asset and must never change. This ID is an opaque, arbitrary type from the XCVM protocol and no assumption must be made on how it is computed.",
          "allOf": [
            {
              "$ref": "#/definitions/Displayed_for_uint128"
            }
          ]
        },
        "AssetItem": {
          "type": "object",
          "required": [
            "asset_id",
            "from_network_id",
            "local"
          ],
          "properties": {
            "asset_id": {
              "$ref": "#/definitions/AssetId"
            },
            "bridged": {
              "anyOf": [
                {
                  "$ref": "#/definitions/BridgeAsset"
                },
                {
                  "type": "null"
                }
              ]
            },
            "from_network_id": {
              "$ref": "#/definitions/NetworkId"
            },
            "local": {
              "$ref": "#/definitions/AssetReference"
            }
          }
        },
        "AssetReference": {
          "description": "Definition of an asset on this local chain to operate with",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "native"
              ],
              "properties": {
                "native": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "a_d_r001"
              ],
              "properties": {
                "a_d_r001": {
                  "type": "object",
                  "required": [
                    "sha256"
                  ],
                  "properties": {
                    "sha256": {
                      "$ref": "#/definitions/HexBinary"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "cw20"
              ],
              "properties": {
                "cw20": {
                  "type": "object",
                  "required": [
                    "contract"
                  ],
                  "properties": {
                    "contract": {
                      "$ref": "#/definitions/Addr"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "BridgeAsset": {
          "type": "object",
          "required": [
            "location_on_network"
          ],
          "properties": {
            "location_on_network": {
              "$ref": "#/definitions/ForeignAssetId"
            }
          }
        },
        "Displayed_for_uint128": {
          "description": "A wrapper around a type which is serde-serialised as a string.\n\nFor serde-serialisation to be implemented for the type `T` must implement `Display` and `FromStr` traits.\n\n``` # use xc_core::Displayed;\n\n#[derive(serde::Serialize, serde::Deserialize)] struct Foo { value: Displayed<u64> }\n\nlet encoded = serde_json_wasm::to_string(&Foo { value: Displayed(42) }).unwrap(); assert_eq!(r#\"{\"value\":\"42\"}\"#, encoded);\n\nlet decoded = serde_json_wasm::from_str::<Foo>(r#\"{\"value\":\"42\"}\"#).unwrap(); assert_eq!(Displayed(42), decoded.value); ```",
          "type": "integer",
          "format": "uint128",
          "minimum": 0.0
        },
        "ForeignAssetId": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "ibc_ics20"
              ],
              "properties": {
                "ibc_ics20": {
                  "$ref": "#/definitions/PrefixedDenom"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "HexBinary": {
          "description": "This is a wrapper around Vec<u8> to add hex de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is similar to `cosmwasm_std::Binary` but uses hex. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "NetworkId": {
          "description": "Newtype for XCVM networks ID. Must be unique for each network and must never change. This ID is an opaque, arbitrary type from the XCVM protocol and no assumption must be made on how it is computed.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "PrefixedDenom": {
          "description": "A type that contains the base denomination for ICS20 and the source tracing information path.",
          "type": "object",
          "required": [
            "base_denom",
            "trace_path"
          ],
          "properties": {
            "base_denom": {
              "description": "Base denomination of the relayed fungible token.",
              "type": "string"
            },
            "trace_path": {
              "description": "A series of `{port-id}/{channel-id}`s for tracing the source of the token.",
              "type": "string"
            }
          }
        }
      }
    }
  }
}
