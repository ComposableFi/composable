syntax = "proto3";

package xcvm;

/// protobuf encoding spec tells that:
/// - any repeated field can be intremingled with other, e.g. `asset A, account, asset B`can happen
/// - also can happend repeats for singular fields, examples `transfer 1, transfer 1` and `asset A, asset A`
/// so proto are not enforce inter field order neither exact once by specfication,
/// so that should be specified on XCVM compatible protocol to use proper protoc

message Program {
  Instructions instructions = 1;
  bytes tag = 2;
}

message Instructions {
  repeated Instruction instructions = 1;
}

message Instruction {
  oneof instruction {
    Transfer transfer = 1;
    Call call = 2;
    Spawn spawn = 3;
  }
}

message Transfer {
  Account destination = 1;
  Assets assets = 2;
}

message Assets {
  // really it could be fixed5 (32 assets), now it is min 2 bytes with second 7 bit encoded
  // `assets` entries are variable size, so total size does no predict count
  // so for linear parser with fow slow metered or fast weighted consensuses are predicatable only with
  // explicit counter
  uint32 count = 1;
  // NOTE: protobuf specs tells that interpreter will retain on latest key, but not enforces unique key
  // NOTE: in our case we are more strict and require one and only one key because interpreters are linear(not buffering)
  map<uint32, Amount> assets = 2;
}

message Call {
  bytes encoded = 1;
}

message Spawn {
  uint32 network = 1;
  bytes salt = 2;
  Assets assets = 3;
  Program program = 4;
}

message Account {
  bytes encoded = 1;
}

message U128 {
  // minimums:
  // using `bytes` - 1 byte type + 1 byte length + 1 byte value, but not 7 bit encoded, so always 2+ bytes (more than 65535 tokens) - 4 bytes total
  // high << 64 + low - 2 byte types + 2 bytes values - 4 bytes
  uint64 high = 1;
  uint64 low = 2;
}

message Amount {
  oneof amount {
    U128 fixed = 1;
    Ratio ratio = 2;
  }
}

message Ratio {  
  // having only enumerator leads to 3+ bytes to encode any fraction of 10000 precision which may be more than half of value
  // so having denumerator adds one byte only, but allows to encode 100 USD of 1B USD ratio if needed
  uint32 numerator = 1;
  uint32 denumerator = 2;
}
