= Design Proposal: Pablo Formalization and Restructure with Constant Product/Liquidity Bootstrapping Pool Unification
:math:
:stem:
:imagesoutdir: images
:imagesdir: images
:toc:
:toclevels: 4
:sectnums:
:sectnumlevels: 4

== Abstract

This document is a review current Pablo implementation and proposes updates to better align the constant product pool(CPP) and liquidity bootstrapping pool(LBP) code with the https://docs.balancer.fi/concepts/math/weighted-math[Balancer protocol] which those implementations are based on.

== Background

Pablo http://link[constant product pool (analogous to Uniswap)] and the liquidity bootstrapping pool implementations are based on the balancer weighted math that is laid out https://dev.balancer.fi/resources/pool-math/weighted-math[here]. However, due to historical evolution of the code the implementations are right now separate and sometimes seems to be inconsistent. Specially the fee calculations that does not seem to follow a standard formula specially when it comes to "in given out" scenario.


== Requirements

. Fees calculations on Pablo MUST align with the math for Balancer pools.
. Liquidity provider token calculations on Pablo MUST align with the math for Balancer pools (taking into account weights).
. Code MUST be re-organized to unify CPP and LBP implementations to avoid divergence and to allow easier maintenance.
. MUST assess risks and propose fail safes

In addition to these hard requirements the idea is also to simplify the code as much as possible to avoid confusion specially regarding the `CurrencyPair` swaps.

== Method

Following is an overview of the proposed changes to the Pablo CPP and LBP implementation.

TODO


=== Fee Math Updates

Given the definition of symbols,

stem:[A_i] : Amount (`A`) of input (`i`) token

stem:[A_"sent"] : Amount of input token sent by the user

stem:[A_o] : Amount of output token (`o`)

stem:[B_i] : Balance (`B`) of input token in the pool

stem:[B_o] : Balance of output token in the pool

stem:[w_i] : weight (`w`) of input token in the pool

stem:[w_o] : weight of output token in the pool

stem:[s] : spot price

stem:[f] : total swap fee

https://balancer.fi/whitepaper.pdf[Balancer white paper] derives the following formulae for calculating,

. Spot price
+
stem:[s = (B_i/w_i) / (B_o / w_o)]
+
When taking the fee into account the formula is adjusted as,
+
stem:[s = (B_i/w_i) / (B_o / w_o) . (1 / (1 - f))] <- (1)
. Out-given-in
+
stem:[A_o = B_o . (1 - (B_i / (B_i + A_i))^(w_i / w_o))]
Here as they recommend the application of fee on the "way-in" with the following approach,
+
stem:[A_o = B_o . (1 - (B_i / (B_i + A_"sent" . (1 - f)))^(w_i / w_o))] <- (2)
. In-given-out
+
stem:[A_i = B_i . ((B_o / (B_o - A_o))^(w_o/w_i) - 1 )]
+
Given that the fee should not affect the amount that the user would like to receive, One can derive the following formula for the "In" amount given the fee (refer <<_proof_of_fee_for_in_given_out>>).
+
stem:[A_"sent" = (B_i / (1 - f)) . ((B_o / (B_o - A_o))^(w_o / w_i) - 1)] <- (3)

The CPP and LBP implementations can directly use (1), (2) and (3) with fees included (as opposed to the current implementation where fees are not part of the core equations). The code at `code/parachain/frame/composable-maths/src/dex/constant_product.rs` must be adjusted for this.

This change could be done in stages,

. Change the functions in the code to include the fee percentage as an input, set the fee as 0 for all uses of those functions.
. Adjust the uses of these functions to provide the actual fee percentage.

=== Liquidity Provider Token (LPT) Math Updates

Original balancer protocol https://metavision-labs.gitbook.io/balancerv2cad/code-and-instructions/balancer_py_edition/weightedpool.py#calc_token_in_given_exact_bpt_out[requires the pool weight of a given currency to be taken into account] when calculating LPT out given the input of a given amount of liquidity in that currency. Rationale being that providing liquidity the amount of received is proportional to the movement of pool invariant (value function). Current LPT math based on https://uniswap.org/whitepaper.pdf[Uniswap v2] though accurate for a 50/50 pool, it does not work when the pool weights are different.

Given the additional symbol definitions,

stem:[P_"issued"] : LPT tokens issued

stem:[P_"supply"] : Existing supply of LPT tokens

stem:[P_"redeemed"] : Redeemed LPT tokens

stem:[D_k] : Deposit (`D`) of token `k`.

As per the requirement of having differentially weighted pools for Pablo, the LPT math needs to be corrected as follows.

. LPT received for deposited liquidity in each pool asset according to the weight ratio (must be validated in code),
+
stem:[P_"issued" = P_"supply" . (D_k / B_k)]
+
This ensures that the increase of LPT is proportional to the increase of the value function(invariant). The concept of an LP tax(equal to swap fee percentage) is introduced to counter the behavior of swapping without fees using add/remove liquidity operations (refer <<_proof_of_proportional_lpt_calculation_for_liquidity_added_in_pool_weight_ratio>>).
+
stem:[P_"issued" = P_"supply" . ((D_k . (1 - f)) / B_k)] <- (4)
. LPT received for deposited liquidity in a single pool asset (`k`),
+
stem:[P_"issued" = P_"supply" . (((D_k + B_k)/ B_k)^(w_k) - 1)]
+
When taking into account LP tax,
+
stem:[P_"issued" = P_"supply" . (((D_k. (1 - f) + B_k)/ B_k)^(w_k) - 1)] <- (5)
+
One could see this formula is a generalization of the formula (4) when stem:[w_k = 1] (sum of all weights). Therefore, equation (5) can be used for both cases to get the amount of LPT issued.
. A sensible default must be derived for the issued LPT for the initial deposit in a pool as otherwise it would always be zero according to above formulae. Here https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/pool-weighted/contracts/BaseWeightedPool.sol#L192[balancer uses] the following formula which keeps the LPT supply consistent across pools.
+
stem:[P_"issued" = k . Pi_"i=0"^k B_i] <- (6)
+
The https://github.com/ComposableFi/composable/blob/main/code/parachain/frame/composable-maths/src/dex/constant_product.rs#L131[current implementation] based on Uniswap must be adjusted to be consistent here.
. Tokens received in each of the assets when withdrawing each type of asset available in a pool
+
stem:[A_k = B_k . (P_"redeemed" / P_"supply")] <- (7)
. Tokens(`k`) received when withdrawing a single asset from a pool (refer <<_proof_of_proportional_lpt_calculation_for_liquidity_added_in_a_single_pool_asset>>)
+
stem:[A_k = B_k . (1 - (1 - P_"redeemed" / P_"supply")^(1/w_k))] <- (8)
+
One could see this formula is a generalization of the formula (7) when stem:[w_k = 1] (sum of all weights). Therefore, equation (8) can be used for both cases to get the amount of tokens received. For all assets case the result must be used as the amount for all pool assets to be disbursed.

As per the derivations above , equations (5), (6) and (8) are the only ones that need to be implemented at `code/parachain/frame/composable-maths/src/dex/constant_product.rs`. Then they must be integrated with relevant flows.

=== Validation: Pool Asset (Pair) Validation Must be at the Top Level of `Amm` trait Implementation

Currently significant amount of logic is executed upfront without validating that the pool contains the given currencies for an operation such as a swap.

=== Validation: the Asset Ratio When Adding Liquidity

The added liquidity must follow the same ratio as the pool weight distribution according to balancer formulae. Currently, there is no such validation.

[#_refactoring_currencypair_usage]
=== Refactoring: `CurrencyPair` Usage

In the existing https://github.com/ComposableFi/composable/blob/main/code/parachain/frame/composable-traits/src/dex.rs#L269[pool data structure], using `CurrencyPair` with "base" and "quote" naming creates confusion when it comes to actual swap logic.A base or quote naming applies to a currency only at the point of a trade.Specially when considering possible multi-asset pools that a balancer based pool supports.

The proposal here is to use a list(vector) of maximum length of 2 (possibly allowing for future expansion) in the pool data structure for both CPP and LBP.

[source,rust]
----
pub struct ConstantProductPoolInfo<AccountId, AssetId> {
	/// Owner of pool
	pub owner: AccountId,
	/// Swappable assets map asset_id => weight
	pub assets: Map<AssetId, Permill>,
	/// AssetId of LP token
	pub lp_token: AssetId,
	/// Amount of the fee pool charges for the exchange
	pub fee_config: FeeConfig,

}

pub struct LiquidityBootstrappingPoolInfo<AccountId, AssetId, BlockNumber> {
	/// Owner of the pool
	pub owner: AccountId,
	/// Asset pair of the pool along their weight.
	/// Base asset is the project token.
	/// Quote asset is the collateral token.
	pub assets: Map<AssetId, Permil>,
	/// Sale period of the LBP.
	pub sale: Sale<BlockNumber>,
	/// Trading fees.
	pub fee_config: FeeConfig,
}
----

=== Unit Test Updates

. Introduce unit tests for `code/parachain/frame/composable-maths/src/dex/constant_product.rs`.
. All unit tests include fees (verified according to the math), with 0 fees being the exception.
. Sufficient amount of cases to cover pools with differential weights according to the math.
. Sufficient amount of cases to cover LPT issued according to the math.

=== Algorithm: `constant_product::out_given_in`

These are the modifications to be made to the existing https://github.com/ComposableFi/composable/blob/main/code/parachain/frame/composable-maths/src/dex/constant_product.rs#L59[function].

[source,rust]
----
pub fn compute_out_given_in<T: PerThing>(
	w_i: T,
	w_o: T,
	b_i: u128,
	b_o: u128,
	a_sent: u128,
    // f=0 for getting "out" without taking into account the fee
    f: T
) -> Result<(/* Out */ u128, /*Fee*/ u128), ArithmeticError> {
    // Calculate according to section 4.1 Eqn: 2
}
----

=== Algorithm: `Amm::currency_pair` -> `Amm::assets`

This is a renaming plus a reorganization of this logic to better match the `CurrencyPair` refactoring. Because of the <<_refactoring_currencypair_usage>>, this function should just return the list of assets in the pool.

[source,rust]
----
pub trait Amm {
    // ....

    fn assets(pool_id: Self::PoolId) -> Result<Vec<AssetId>, DispatchError>;

    // ....
}
----

[plantuml,images/pablo-amm-currencies,png]
----
start
->pool_id;
:pool = get pool from storage by pool_id;
:return pool.assets.keys();
stop
----

=== Algorithm: `Amm::get_exchange_value`

Having the fee not taken into account here causes the fees to be calculated in non-formal ways. Therefore, the proposal is to always take into account the fee input as a parameter and return the fee as a separate output. This also means that this function shall not be used to calculate a quote amount for buy operations.

[source,rust]
----
pub struct AssetAmount<AssetId, Balance> {
    pub asset_id: AssetId,
    pub amount: Balance
}

pub struct ExchangeValue<AssetId, Balance> {
    value: AssetAmount<AssetId, Balance>,
    fee: AssetAmount<AssetId, Balance>,
}

pub trait Amm {
    // ....

    /// Return the exchange value out asset given in asset.
    fn get_exchange_value(
        pool_id: Self::PoolId,
        in_asset: AssetAmount<Self::AssetId, Self::Balance>,
        out_asset: Self::AssetId,
    ) -> Result<ExchangeValue<Self::AssetId, Self::Balance>, DispatchError>;

    // ....
}
----

[plantuml,images/pablo-amm-get-exchange-value,png]
----
start
->pool_id,in_asset,out_asset;
:validate assets are part of the pool;
:pool = get pool from storage by pool_id;
:balances = get balances for in_asset and out_asset;
:value, fee = constant_product::out_given_in(
pool.assets[in_asset.asset_id],
pool.assets[out_asset],
balances[0],
balances[1],
in_asset.amount,
pool.fee_config.fee_rate
);
:return ExchangeValue(value, fee);
stop
----

=== Algorithm: `Amm::exchange` -> `Amm::swap`

Given the previously defined `Amm::get_exchange_value` function this method can be simplified.

[source,rust]
----
pub trait Amm {
    // ....

    /// Performs an exchange to transfer the given
    /// quote amount to the pool while disbursing
    /// the calculated base amount according to the pool logic.
    /// Returns the disbursed value in base and fee charged.
    fn swap(
        who: &Self::AccountId,
        pool_id: Self::PoolId,
        in_asset: AssetAmount<Self::AssetId, Self::Balance>,
        min_receive: AssetAmount<Self::AssetId, Self::Balance>,
        keep_alive: bool,
    ) -> Result<ExchangeValue<Self::AssetId, Self::Balance>, DispatchError>;

    // ....
}
----


[plantuml,images/pablo-amm-exchange,png]
----
start
->who,pool_id,in_asset,min_receive;
:validate who actually has the in_asset amount;
:exchange_value =
    Self::get_exchange_value(
        pool_id,
        in_asset,
        min_receive.asset_id
    );
:validate min_receive <= exchange_value;
:transfer in_asset to the pool account;
:transfer exchange_value to who;
:return exchange_value;
stop
----

=== Algorithm: `Amm::sell`

This would be removed to keep the interface simple as `Amm::swap` satisfies the requirement.

=== Algorithm: `Amm::buy`

This function exists to provide a way for a user to easily by a given amount from the AMM.

=== Algorithm: `Amm::add_liquidity`

=== Algorithm: `Amm::remove_liquidity`

=== Fail Safes

Fail safes can be categorized based on the level they act on,

==== At the protocol level, where the entire Pablo protocol in multiple pallets is affected.
==== At the pallet level, where a particular Pablo pallet is affected.
==== At the pool type level where all pools of a particular pool type like LBP is affected.
==== At the individual pool level where a single pool is affected

For LBPs,

. There needs to be a way to pause trading in situations where the trading activity is not favourable for the launch

==== At the functionality level where a particular functionality for example like "removing liquidity" is affected.

== Implementation


== Quality Assurance



== Audit

== Questions

. Would LBPs need to be converted to normal CPP after the sale has ended?
.. If so need to combine CPP and LBP data structures

[#_proof_of_fee_for_in_given_out]
[appendix]
== Proof of Fee for "In-given-out"

Fees are calculated on the "way-in" so starting with formula (2) in the "Fee Math" section we have,

stem:[A_o = B_o . (1 - (B_i / (B_i + A_"sent" . (1 - f)))^(w_i / w_o))]

We can arrange this to know how to send(stem:[A_"sent"]) given the out, we can isolate it,

stem:[1 - A_o / B_o = (B_i / (B_i + A_"sent" . (1 - f)))^(w_i / w_o)]

stem:[(1 - A_o / B_o)^(w_o/w_i) = B_i / (B_i + A_"sent" . (1 - f))]

stem:[(1 / (1 - A_o / B_o))^(w_o/w_i) = 1 + A_"sent" . (1 - f) / B_i]

stem:[(1 / (1 - A_o / B_o))^(w_o/w_i) = 1 + A_"sent" . (1 - f) / B_i]

stem:[(B_o / (B_o - A_o))^(w_o/w_i) - 1 = A_"sent" . (1 - f) / B_i]

Now we get equation (3),

stem:[ A_"sent"  = B_o / (1 - f) . (B_o / (B_o - A_o))^(w_o/w_i) - 1]

proven.

[#_proof_of_proportional_lpt_calculation_for_liquidity_added_in_a_single_pool_asset]
[appendix]
== Proof of Proportional LPT Calculation for Liquidity Added in a Single Pool Asset

Pool invariant is given by,

stem:[Pi_i B_i^(w_i) = C] <-(a)

Given liquidity provided for the token `k`, We would like to issue stem:[P_"issued"] such that movement of `c` is propotional to it,

stem:[P_"issued" / P_"supply" = (Delta C) / C ] <-(b)

after increasing the balance (deposit) of k by stem:[A_k] using the invariant above we have,

stem:[(B_k + D_k)^(w_k) . Pi_"i!=k" B_i^i = C + Delta C] <-(c)

with (c) / (a), we have,

stem:[(1 + D_k / B_k)^(w_k) = 1 + (Delta C) / C]

Now with (b),

stem:[(1 + D_k / B_k)^(w_k) = 1 + P_"issued" / P_"supply"]

stem:[P_"issued" / P_"supply" = (1 + D_k / B_k)^(w_k) - 1 ]

With fees on the way in, we have,

stem:[P_"issued" / P_"supply" = (1 + ((1 - f) . D_k) / B_k)^(w_k) - 1 ]

Now with rearrangement we have,

stem:[P_"issued" = P_"supply" . (((D_k. (1 - f) + B_k)/ B_k)^(w_k) - 1)]

Thus, this proves equation (5).

[#_proof_of_proportional_lpt_calculation_for_liquidity_added_in_pool_weight_ratio]
[appendix]
== Proof of Proportional LPT Calculation for Liquidity Added in Pool Weight Ratio

Pool invariant is given by,

stem:[Pi_i B_i^(w_i) = C] <-(a)

Note that weights are normalized such that,

stem:[Sigma w_i = 1] <-(b)

Given liquidity provided for the token `k`, We would like to issue stem:[P_"issued"] such that movement of `c` is propotional to it,

stem:[P_"issued" / P_"supply" = (Delta C) / C ] <-(c)

With (a) when adding liquidity to all assets proportional to the pool weights we have,

stem:[Pi_i (B_i + D_i)^(w_i) = C + Delta C] <-(d)

With (d) / (a),

stem:[Pi_i (1 + (D_i) / B_i)^(w_i) = 1 + (Delta C) / C]

As the liquidity is deposited in proportion to normalized weights, for all `i`,

stem:[D_i / B_i = k]

Where `k` is some constant. Then applying (b),

stem:[1 + D_i / B_i = 1 + (Delta C) / C]

Then with (c),

stem:[D_i / B_i = P_"issued" / P_"supply"]

Applying fee on the way-in

stem:[D_i . (1 - f) / B_i = P_"issued" / P_"supply"]

With rearrangement,

stem:[P_"issued" = P_"supply" . ((D_k . (1 - f)) / B_k)]

Thus proves equation (4).






