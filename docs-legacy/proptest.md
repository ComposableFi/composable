# Introduction

At Composable, we strive to write correct code. We all know that having rigorous
code review and meticulous developers is not enough. In a perfect world, every
piece of software would be generated by theorem provers. Unfortunately, this is
rarely the case.

Writing tests with hardcoded/chose inputs is something affordable that any
software engineer can understand. This is a simple form of verification which is
limited in many cases. We believe that using property testing (+ fuzzing) is a
step towards the goal of having a more robust code.

# Properties

## Introduction

Most of the time, we, developers, are used to a wide variety of tests flavors
(unit, integration...). But we rarely back any of them with a
property/invariant. Although writing these tests is already a mark of quality,
it is not sufficient and lacks meaning. Adding to that the fact that we highly
likely implement them using arbitrary, usually well-known values, they lose the
whole point of _verifying something we don't forcibly expect_.

The idea here would be to find properties that our code should hold and then use
random input generation to test them. This technique is also called fuzzing but
I would argue that it is different. The difference comes from the fact that we
will split the input domain to assert certain properties.

The examples will directly be extracted from [the Composable
repository](https://github.com/ComposableFi/composable). To be more precise, we
will only use the [Vault
pallet](https://github.com/ComposableFi/composable/tree/main/frame/vault).
However, to generalize these ideas over arbitrary projects, we will try to stay a bit abstract.

## Determining a property

Before being able to determine any property, we have to understand the code we
are working on. The Vault allows strategies to operate on users funds. Users are
able to deposit an arbitrary amount and get LP tokens representing their share
of the vault. They later can withdraw using these LPs. Usually, this kind of
protocol's purpose is to have a better capital efficiency and optimize APY over
this capital.

One of the easiest properties here is the fact that `withdraw . deposit =
identity`. This means that if a user **deposit** and then **withdraw**, the vault
should be unchanged and the user balance should be unchanged. Note that the
**amount** is not part of the equation, which allows us to generate any
amount and assert this property.

## Generating random inputs

Recall the `withdraw . deposit = identity` which we just found. We said that the
amount was not part of the property. Interestingly, we no longer need to have
hardcoded values as long as they are not part of the equation.

Usually, the property we want to check is valid for the whole input domain. But
this is not always the case (it should probably be enforced but in practice, we
encounter a lot of functions like this). For our example, any **amount** is
valid for the property to hold, the generating function will be simple.
This example we are going to work on is extracted from [the Vault tests](https://github.com/ComposableFi/composable/blob/71af1080f3c89233e289e41b3a249d0966aa1147/frame/vault/src/tests.rs#L271).

Let's assume that the `deposit` and `withdraw` functions are using a `type
Balance = u128` as input, using proptest [`prop_compose!`](https://altsysrq.github.io/rustdoc/proptest/1.0.0/proptest/macro.prop_compose.html) macro, we can create a
generator function like:
```rust
prop_compose! {
	fn random_valid_amount()(x in 0..Balance::MAX) -> Balance {
		x
	}
}
```

## Using generator function in tests inputs

The `random_valid_amount` generator we just defined can directly be used to
generate random inputs for functions defined inside proptest [`proptest!`](https://altsysrq.github.io/rustdoc/proptest/1.0.0/proptest/macro.proptest.html) macro:
```rust
proptest! {
    // Declare that every test within this macro should be executed 10_000 times (new random input each time) to pass.
    #![proptest_config(ProptestConfig::with_cases(10_000))]
    
    #[test]
    fn test_withdraw_deposit_identity(amount in random_valid_amount()) {
        // TODO: check our property using the random `amount`
        // recall that this function we be executed 10_000 times when running `cargo test`
    }
}
```

Note that proptest does already include our `random_valid_amount` function in
it's prelude, under the name `any`. We basically can use `any::<Balance>()`, but
let's imagine we want more advanced random generation, such as saying I want the
balance to start at an arbitrary value `X`. This can be achieved with the
previous `prop_compose!` macro:
```rust
prop_compose! {
    // assume that the minimum useful (or even valid for the property) amount is 0x1337
    fn random_valid_amount()(x in 0x1337..Balance::MAX) -> Balance {
	    x
    }
}
```

This small introduction is not meant to fully cover proptest but rather to give a quick and practical overview of its feature. To learn more about it, you should probably read [the proptest documentation](https://altsysrq.github.io/rustdoc/proptest/1.0.0/proptest/index.html).

## Setting up a pallet for proptests
First, add the `proptest` and `composable-tests-helpers` dev-dependencies to the pallet's `Cargo.toml`:
```toml
[dev-dependencies]
proptest = "1.0.0" # or a newer version 
composable-tests-helpers = { path = "../composable-tests-helpers", default-features = false }
```

Then, within the pallet's `tests.rs`, use `proptest` and `composable_tests_helpers`:
```rust
use proptest::prelude::*;
use composable_tests_helpers::{prop_assert_noop, prop_assert_ok};

```

Finally, like mentioned above, wrap the existing tests in a `proptest!` macro, 
replace hardcoded test values with the randomly generated values,
and replace the following macros:
- `assert_noop` => `prop_assert_noop`
- `assert_ok` => `prop_assert_ok`
- `assert_eq` => `prop_assert_eq`
