{"version":3,"file":"substrate-react.cjs.production.min.js","sources":["../src/extrinsics/store/extrinsics/extrinsics.utils.ts","../src/extrinsics/store/useStore.ts","../src/extrinsics/store/extrinsics/extrinsics.slice.ts","../src/extrinsics/Executor.ts","../src/extrinsics/ExecutorProvider.tsx","../src/dotsama/Networks.ts","../src/dotsama/DotSamaContext.tsx","../src/dotsama/utils.ts","../src/dotsama/hooks/index.ts","../src/extrinsics/hooks/index.ts"],"sourcesContent":["import produce from 'immer';\nimport {\n  ExtrinsicMetadata,\n  ExtrinsicSlice,\n  ExtrinsicStatus,\n} from './extrinsics.types';\n\nexport const putTransactionData = (\n  transactions: ExtrinsicSlice['extrinsics'],\n  txHash: string,\n  data: ExtrinsicMetadata\n) => {\n  return produce(transactions, draft => {\n    draft[txHash] = data;\n  });\n};\n\nexport const putTrasactionStatus = (\n  transactions: ExtrinsicSlice['extrinsics'],\n  txHash: string,\n  status: ExtrinsicStatus\n) => {\n  return produce(transactions, draft => {\n    if (draft[txHash]) {\n      draft[txHash].status = status;\n    }\n  });\n};\n\nexport const putTransactionError = (\n  transactions: ExtrinsicSlice['extrinsics'],\n  txHash: string,\n  errorMessage: string\n) => {\n  return produce(transactions, draft => {\n    if (draft[txHash]) {\n      draft[txHash].status = 'Error';\n      draft[txHash].dispatchError = errorMessage;\n    }\n  });\n};\n\nexport const putBlockHash = (\n  transactions: ExtrinsicSlice['extrinsics'],\n  txHash: string,\n  blockHash: string\n) => {\n  return produce(transactions, draft => {\n    if (draft[txHash]) {\n      draft[txHash].status = 'isInBlock';\n      draft[txHash].blockHash = blockHash;\n    }\n  });\n};\n","import create from 'zustand';\nimport extrinsicsSlice from './extrinsics/extrinsics.slice';\n\nconst useStore = create(set => ({\n  ...extrinsicsSlice(set),\n}));\n\nexport default useStore;\n","import { StoreSlice } from '../types';\nimport {\n  ExtrinsicSlice,\n  ExtrinsicMetadata,\n  ExtrinsicStatus,\n} from './extrinsics.types';\nimport {\n  putTransactionData,\n  putBlockHash,\n  putTrasactionStatus,\n  putTransactionError,\n} from './extrinsics.utils';\n\nconst createExtrinsicsSlice: StoreSlice<ExtrinsicSlice> = set => ({\n  extrinsics: {},\n  addExtrinsic: (\n    transactionHash: string,\n    extrinsicCall: Omit<ExtrinsicMetadata, 'dispatchError'>\n  ) =>\n    set((prev: ExtrinsicSlice) => ({\n      extrinsics: putTransactionData(\n        prev.extrinsics,\n        transactionHash,\n        extrinsicCall\n      ),\n    })),\n  addBlockHash: (transactionHash: string, blockHash: string) =>\n    set((prev: ExtrinsicSlice) => ({\n      extrinsics: putBlockHash(prev.extrinsics, transactionHash, blockHash),\n    })),\n  updateExtrinsicStatus: (\n    transactionHash: string,\n    extrinsicStatus: ExtrinsicStatus\n  ) =>\n    set((prev: ExtrinsicSlice) => ({\n      extrinsics: putTrasactionStatus(\n        prev.extrinsics,\n        transactionHash,\n        extrinsicStatus\n      ),\n    })),\n  updateExtrinsicError: (transactionHash: string, errorMessage: string) =>\n    set((prev: ExtrinsicSlice) => ({\n      extrinsics: putTransactionError(\n        prev.extrinsics,\n        transactionHash,\n        errorMessage\n      ),\n    })),\n});\n\nexport default createExtrinsicsSlice;\n","import { ApiPromise, SubmittableResult } from '@polkadot/api';\nimport {\n  SubmittableExtrinsic,\n  AddressOrPair,\n  Signer,\n} from '@polkadot/api/types';\nimport { EventRecord } from '@polkadot/types/interfaces/system';\nimport {\n  ExtrinsicSlice,\n  ExtrinsicMetadata,\n} from './store/extrinsics/extrinsics.types';\n\ninterface TransactionExecutor {\n  execute(\n    call: SubmittableExtrinsic<'promise'>,\n    sender: AddressOrPair,\n    api: ApiPromise,\n    signer: Signer,\n    onTxReady: (txHash: string) => void | undefined,\n    onTxFinalized: (txHash: string, events: EventRecord[]) => void | undefined,\n    onTxError?: (errorMessage: string) => void\n  ): Promise<void>;\n  executeUnsigned(\n    call: SubmittableExtrinsic<'promise'>,\n    api: ApiPromise,\n    onTxReady: (txHash: string) => void | undefined,\n    onTxFinalized: (txHash: string) => void | undefined\n  ): Promise<void>;\n}\n\nclass Executor implements TransactionExecutor {\n  private addExtrinsic: ExtrinsicSlice['addExtrinsic'];\n  private addBlockHash: ExtrinsicSlice['addBlockHash'];\n  private updateExstrinsicStatus: ExtrinsicSlice['updateExtrinsicStatus'];\n  private updateExtrinsicError: ExtrinsicSlice['updateExtrinsicError'];\n\n  constructor(\n    addExtrinsic: ExtrinsicSlice['addExtrinsic'],\n    addBlockHash: ExtrinsicSlice['addBlockHash'],\n    updateExstrinsicStatus: ExtrinsicSlice['updateExtrinsicStatus'],\n    updateExtrinsicError: ExtrinsicSlice['updateExtrinsicError']\n  ) {\n    this.addExtrinsic = addExtrinsic;\n    this.addBlockHash = addBlockHash;\n    this.updateExstrinsicStatus = updateExstrinsicStatus;\n    this.updateExtrinsicError = updateExtrinsicError;\n  }\n\n  /**\n   * Execute an API Call (legacy or not?)\n   * @param call a submittable extrinsic from Polkadot/api\n   * @param sender address of the user\n   * @param api polkadot api itself\n   * @param signer signer from an extension wallet\n   * @param onTxFinalized this should be optional\n   */\n  async execute(\n    call: SubmittableExtrinsic<'promise'>,\n    sender: AddressOrPair,\n    api: ApiPromise,\n    signer: Signer,\n    onTxReady: (txHash: string) => void | undefined,\n    onTxFinalized: (txHash: string, events: EventRecord[]) => void | undefined,\n    onTxError?: (errorMessage: string) => void | undefined\n  ): Promise<void> {\n    const unsub = await call.signAndSend(sender, { signer }, txResult => {\n      const txHash = txResult.txHash.toString().toLowerCase();\n\n      if (txResult.status.isReady) {\n        this.onReady(call, txResult, sender, true);\n\n        if (onTxReady) {\n          onTxReady(txHash);\n        }\n      }\n\n      if (txResult.dispatchError) {\n        const error = this.onDispatchError(txResult, api);\n        if (onTxError) onTxError(error);\n        unsub();\n      }\n\n      if (txResult.isFinalized) {\n        this.onFinalized(txHash);\n\n        if (onTxFinalized) {\n          onTxFinalized(txHash, txResult.events);\n        }\n        unsub();\n      }\n    });\n  }\n\n  async executeUnsigned(\n    call: SubmittableExtrinsic<'promise'>,\n    api: ApiPromise,\n    onTxReady: (txHash: string) => void | undefined,\n    onTxFinalized: (txHash: string) => void | undefined\n  ): Promise<void> {\n    const unsub = await call.send(txResult => {\n      const txHash = txResult.txHash.toString().toLowerCase();\n      if (txResult.status.isReady) {\n        this.onReady(call, txResult, '', false);\n        if (onTxReady) onTxReady(txHash);\n      }\n\n      if (txResult.status.isInBlock) {\n        this.onBlockInclusion(txResult);\n      }\n\n      if (txResult.dispatchError) {\n        this.onDispatchError(txResult, api);\n        unsub();\n      }\n\n      if (txResult.isFinalized && !txResult.dispatchError) {\n        this.onFinalized(txHash);\n        if (onTxFinalized) onTxFinalized(txHash);\n        unsub();\n      }\n    });\n  }\n\n  private async onReady(\n    call: SubmittableExtrinsic<'promise'>,\n    txResult: SubmittableResult,\n    sender: AddressOrPair,\n    isSigned: boolean\n  ) {\n    const serialized: any = call.toHuman();\n    const txHash = txResult.txHash.toString().toLowerCase();\n    const payload: ExtrinsicMetadata = {\n      hash: txHash,\n      method: serialized.method.method,\n      section: serialized.method.section,\n      sender: sender.toString(),\n      args: serialized.method.args,\n      dispatchError: undefined,\n      status: 'isReady',\n      isSigned,\n      timestamp: Date.now(),\n    };\n\n    this.addExtrinsic(txHash, payload);\n  }\n\n  private onDispatchError(txResult: SubmittableResult, api: ApiPromise) {\n    let errorMessage = ``;\n    let txHash = txResult.txHash.toString().toLowerCase();\n\n    if (txResult.dispatchError) {\n      if (txResult.dispatchError.isModule) {\n        const decoded = api.registry.findMetaError(\n          txResult.dispatchError.asModule\n        );\n        const { docs, name, section } = decoded;\n\n        errorMessage = `${section}.${name}: ${docs.join(' ')}`;\n      } else {\n        errorMessage = txResult.dispatchError.toString();\n      }\n    }\n\n    this.updateExtrinsicError(txHash, errorMessage);\n    return errorMessage;\n  }\n\n  private async onBlockInclusion(txResult: SubmittableResult) {\n    let txHash = txResult.txHash.toString().toLowerCase();\n    let blockHash = txResult.status.asInBlock.toString().toLowerCase();\n\n    this.addBlockHash(txHash, blockHash);\n  }\n\n  private async onFinalized(txHash: string) {\n    this.updateExstrinsicStatus(txHash, 'isFinalized');\n  }\n}\n\nexport default Executor;\n","import React, { useMemo } from 'react';\nimport Executor from './Executor';\nimport useStore from './store/useStore';\n/**\n * As zustand useStore is a hook\n * we need to create a context and wrap\n * executor in a provider to be able to\n * use useStore methods via executor\n *\n * exectuor would expose execute and executeUnsigned\n * methods to be able to execute extrsinsic calls\n */\nconst ExecutorContext = React.createContext({\n  executor: undefined as Executor | undefined,\n});\n\nexport const ExecutorProvider = ({\n  children,\n}: {\n  children: React.ReactNode;\n}) => {\n  /**\n   * Use store updaters\n   * from zustand store\n   */\n  const {\n    addExtrinsic,\n    addBlockHash,\n    updateExtrinsicStatus,\n    updateExtrinsicError,\n  } = useStore();\n  /**\n   * Create and memoize executor\n   */\n  const executor = useMemo<Executor>(() => {\n    return new Executor(\n      addExtrinsic,\n      addBlockHash,\n      updateExtrinsicStatus,\n      updateExtrinsicError\n    );\n  }, [addExtrinsic, addBlockHash, updateExtrinsicStatus, updateExtrinsicError]);\n\n  return (\n    <ExecutorContext.Provider\n      value={{\n        executor,\n      }}\n    >\n      {children}\n    </ExecutorContext.Provider>\n  );\n};\n\n/**\n * Hook that returns an extrinsics executor\n * @returns Executor\n */\nexport const useExecutor = (): Executor | undefined => {\n  return React.useContext(ExecutorContext).executor;\n};\n","import {\n  ParachainId,\n  ParachainNetwork,\n  RelayChainId,\n  RelaychainNetwork,\n} from './types';\n\nexport const ParachainNetworks: {\n  [parachainId in ParachainId]: ParachainNetwork;\n} = {\n  picasso: {\n    name: 'Picasso',\n    wsUrl: 'wss://picasso-rpc.composable.finance',\n    tokenId: 'pica',\n    prefix: 49,\n    accountType: '*25519',\n    subscanUrl: '',\n    decimals: 12,\n    color: '#B09A9F',\n    symbol: 'PICA',\n    logo:\n      'https://raw.githubusercontent.com/TalismanSociety/chaindata/2778d4b989407a2e9fca6ae897fe849561f74afe/assets/picasso/logo.svg',\n    parachainId: 2087,\n    relayChain: 'kusama',\n  },\n  karura: {\n    name: 'Karura',\n    wsUrl: 'wss://karura-rpc-0.aca-api.network',\n    tokenId: 'kar',\n    prefix: 8,\n    accountType: '*25519',\n    subscanUrl: 'https://karura.subscan.io/',\n    decimals: 12,\n    color: '#ff4c3b',\n    symbol: 'KAR',\n    logo:\n      'https://raw.githubusercontent.com/TalismanSociety/chaindata/2778d4b989407a2e9fca6ae897fe849561f74afe/assets/karura/logo.svg',\n    parachainId: 2000,\n    relayChain: 'kusama',\n  },\n};\n\nexport const RelayChainNetworks: {\n  [relaychainId in RelayChainId]: RelaychainNetwork;\n} = {\n  kusama: {\n    name: 'Kusama',\n    color: '#000000',\n    prefix: 2,\n    logo:\n      'https://raw.githubusercontent.com/TalismanSociety/chaindata/2778d4b989407a2e9fca6ae897fe849561f74afe/assets/kusama/logo.svg',\n    networkId: 'kusama',\n    accountType: '*25519',\n    wsUrl: 'wss://kusama-rpc.polkadot.io',\n    subscanUrl: 'https://kusama.subscan.io/',\n    decimals: 12,\n    tokenId: 'ksm',\n    symbol: 'KSM',\n  },\n  polkadot: {\n    name: 'Polkadot',\n    color: '#e6007a',\n    prefix: 0,\n    logo:\n      'https://raw.githubusercontent.com/TalismanSociety/chaindata/2778d4b989407a2e9fca6ae897fe849561f74afe/assets/polkadot/logo.svg',\n    networkId: 'polkadot',\n    accountType: '*25519',\n    wsUrl: 'wss://rpc.polkadot.io',\n    subscanUrl: 'https://polkadot.subscan.io/',\n    decimals: 10,\n    tokenId: 'dot',\n    symbol: 'DOT',\n  },\n};\n\nexport const getParachainNetwork = (\n  parachainId: ParachainId\n): ParachainNetwork => ParachainNetworks[parachainId];\nexport const getRelaychainNetwork = (\n  relaychainId: RelayChainId\n): RelaychainNetwork => RelayChainNetworks[relaychainId];\n","import { ApiPromise } from '@polkadot/api';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport React, { useState, useEffect, createContext } from 'react';\nimport {\n  DotSamaContext,\n  ParachainApi,\n  DotSamaExtensionStatus,\n  ParachainId,\n  RelaychainApi,\n  RelayChainId,\n} from './types';\nimport { ParachainNetworks, RelayChainNetworks } from './Networks';\n\nconst PARACHAIN_PROVIDERS_DEFAULT: {\n  [chainId in ParachainId]: ParachainApi;\n} = Object.entries(ParachainNetworks)\n  .map(([chainId, network]) => {\n    return {\n      chainId: chainId,\n      parachainApi: undefined,\n      apiStatus: 'initializing',\n      prefix: network.prefix,\n      accounts: [],\n    };\n  })\n  .reduce((acc, curr) => {\n    return {\n      ...acc,\n      [curr.chainId]: curr,\n    };\n  }, {} as { [chainId in ParachainId]: ParachainApi });\n\nconst RELAYCHAIN_PROVIDERS_DEFAULT: {\n  [chainId in RelayChainId]: RelaychainApi;\n} = Object.entries(RelayChainNetworks)\n  .map(([chainId, network]) => {\n    return {\n      chainId: chainId,\n      parachainApi: undefined,\n      apiStatus: 'initializing',\n      prefix: network.prefix,\n      accounts: [],\n    };\n  })\n  .reduce((acc, curr) => {\n    return {\n      ...acc,\n      [curr.chainId]: curr,\n    };\n  }, {} as { [chainId in RelayChainId]: RelaychainApi });\n\nexport const DotsamaContext = createContext<DotSamaContext>({\n  parachainProviders: PARACHAIN_PROVIDERS_DEFAULT,\n  relaychainProviders: RELAYCHAIN_PROVIDERS_DEFAULT,\n  extensionStatus: 'initializing',\n  activate: undefined,\n  selectedAccount: -1,\n});\n\nexport const DotSamaContextProvider = ({\n  supportedParachains,\n  children,\n  appName,\n}: {\n  appName: string;\n  supportedParachains: {\n    chainId: ParachainId;\n    rpcUrl: string;\n    rpc: any;\n    types: any;\n  }[];\n  children: React.ReactNode;\n}) => {\n  const [parachainProviders, setParachainProviders] = useState<\n    { [chainId in ParachainId]: ParachainApi }\n  >(PARACHAIN_PROVIDERS_DEFAULT);\n  const [relaychainProviders, setRelayChainProviders] = useState<\n    { [chainId in RelayChainId]: RelaychainApi }\n  >(RELAYCHAIN_PROVIDERS_DEFAULT);\n\n  const activate = async (): Promise<any[] | undefined> => {\n    setExtension(s => {\n      s.extensionStatus = 'connecting';\n      return s;\n    });\n\n    let extensionExists = true;\n    let inectedExtesions;\n    try {\n      const extensionPkg = await import('@polkadot/extension-dapp');\n      inectedExtesions = await extensionPkg.web3Enable(appName);\n      extensionExists = inectedExtesions.length !== 0;\n    } catch (e) {\n      console.error(e);\n      extensionExists = false;\n    }\n\n    if (!extensionExists) {\n      setExtension(s => {\n        s.extensionStatus = 'no_extension';\n        return s;\n      });\n      return inectedExtesions;\n    }\n\n    setExtension(s => {\n      s.extensionStatus = 'connected';\n      return s;\n    });\n\n    for (let i = 0; i < supportedParachains.length; i++) {\n      const { chainId } = supportedParachains[i];\n      const { prefix } = ParachainNetworks[chainId];\n\n      try {\n        const extensionPkg = await import('@polkadot/extension-dapp');\n        const accounts = await extensionPkg.web3Accounts({\n          ss58Format: prefix,\n        });\n\n        setParachainProviders(s => {\n          s[chainId].accounts = accounts.map((x, i) => ({\n            address: x.address,\n            name: x.meta.name ?? i.toFixed(),\n          }));\n          return { ...s };\n        });\n\n        // setting default account\n        setSelectedAccount(accounts.length ? 0 : -1);\n      } catch (e) {\n        console.error(e);\n        continue;\n      }\n    }\n\n    return inectedExtesions;\n  };\n\n  const deactivate = async (): Promise<void> => {\n    setExtension(s => {\n      s.extensionStatus = 'initializing';\n      return s;\n    });\n\n    for (let i = 0; i < supportedParachains.length; i++) {\n      setParachainProviders(s => {\n        const { chainId } = supportedParachains[i];\n        s[chainId].accounts = [];\n        return { ...s };\n      });\n\n      setSelectedAccount(-1);\n\n      return Promise.resolve();\n    }\n  };\n\n  const [extension, setExtension] = useState<{\n    extensionStatus: DotSamaExtensionStatus;\n    activate: () => Promise<any[] | undefined>;\n    deactivate: () => Promise<void>;\n  }>({\n    extensionStatus: 'initializing',\n    activate,\n    deactivate,\n  });\n\n  useEffect(() => {\n    for (let i = 0; i < supportedParachains.length; i++) {\n      const { rpcUrl, chainId, rpc, types } = supportedParachains[i];\n      const { prefix } = ParachainNetworks[chainId];\n\n      // just so we can activate ASAP (where ss58Format is needed)\n      // setParachainProviders(s => {\n      //   s[chainId] = {\n      //     parachainApi: undefined,\n      //     apiStatus: 'initializing',\n      //     accounts: [],\n      //     prefix,\n      //     chainId,\n      //   };\n      //   return s;\n      // });\n\n      const wsProvider = new WsProvider(rpcUrl);\n      const parachainApi = new ApiPromise({ provider: wsProvider, rpc, types });\n\n      parachainApi.isReady\n        .then((parachainApi: ApiPromise) => {\n          setParachainProviders(s => {\n            if (!(chainId in parachainProviders)) {\n              s[chainId] = {\n                chainId,\n                parachainApi: parachainApi,\n                apiStatus: 'connected',\n                accounts: [],\n                prefix,\n              };\n            } else {\n              s[chainId].apiStatus = 'connected';\n              s[chainId].parachainApi = parachainApi;\n            }\n            return s;\n          });\n        })\n        .catch((e: any) => {\n          console.error(e);\n          setParachainProviders(s => {\n            s[chainId] = {\n              chainId,\n              parachainApi: undefined,\n              apiStatus: 'failed',\n              accounts: [],\n              prefix,\n            };\n            return s;\n          });\n        });\n    }\n  }, []);\n\n  const [selectedAccount, setSelectedAccount] = useState<number | -1>(-1);\n\n  return (\n    <DotsamaContext.Provider\n      value={{\n        relaychainProviders,\n        parachainProviders,\n        setSelectedAccount,\n        selectedAccount,\n        ...extension,\n      }}\n    >\n      {children}\n    </DotsamaContext.Provider>\n  );\n};\n","export const getSigner = async (\n  applicationName: string,\n  address: string\n): Promise<any> => {\n  const extensionPackage = await import('@polkadot/extension-dapp');\n  const { web3FromAddress, web3Enable } = extensionPackage;\n  await web3Enable(applicationName);\n  const injector = await web3FromAddress(address);\n  return injector.signer;\n};\n","import React from 'react';\nimport { DotsamaContext } from '../DotSamaContext';\nimport {\n  ConntectedAccount,\n  DotSamaContext,\n  ParachainId,\n  RelayChainId,\n} from '../types';\n\nexport const useDotSamaContext = (): DotSamaContext => {\n  return React.useContext(DotsamaContext);\n};\n\nexport const useParachainApi = (parachainId: ParachainId) => {\n  const { parachainProviders } = React.useContext(DotsamaContext);\n  return parachainProviders[parachainId];\n};\n\nexport const useRelayChainApi = (relaychainId: RelayChainId) => {\n  const { relaychainProviders } = React.useContext(DotsamaContext);\n  return relaychainProviders[relaychainId];\n};\n\nexport const useSelectedAccount = (\n  parachainId: ParachainId\n): ConntectedAccount | undefined => {\n  const { selectedAccount, parachainProviders } = React.useContext(\n    DotsamaContext\n  );\n  const { accounts } = parachainProviders[parachainId];\n  return selectedAccount !== -1 ? accounts[selectedAccount] : undefined;\n};\n","import { useMemo } from 'react';\nimport {\n  ExtrinsicMetadata,\n  ExtrinsicSlice,\n  ExtrinsicStatus,\n} from '../store/extrinsics/extrinsics.types';\nimport useStore from '../store/useStore';\n\nexport const useExtrinsics = (): ExtrinsicSlice['extrinsics'] => {\n  const { extrinsics } = useStore();\n  return extrinsics;\n};\n\nfunction isPending(extrinsicStatus: ExtrinsicStatus): boolean {\n  if (extrinsicStatus !== 'isFinalized' && extrinsicStatus !== 'Error') {\n    return true;\n  }\n  return false;\n}\n\nexport const usePendingExtrinsic = (\n  method: string,\n  section: string,\n  sender: string\n): boolean => {\n  const { extrinsics } = useStore();\n\n  let _isPendingExtrinsic = useMemo(() => {\n    const sortedTxs = Object.values(extrinsics).sort((a, b) => {\n      return a.timestamp - b.timestamp;\n    });\n\n    for (const tx of sortedTxs) {\n      if (\n        tx.method === method &&\n        section === tx.section &&\n        tx.sender === sender\n      ) {\n        if (isPending(tx.status)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }, [extrinsics]);\n\n  return _isPendingExtrinsic;\n};\n\nexport const useExtrinsicCalls = (\n  method: string,\n  section: string,\n  sender: string\n): ExtrinsicMetadata[] => {\n  const { extrinsics } = useStore();\n\n  const extrinsicCalls = useMemo(() => {\n    let calls = [];\n\n    for (const tx of Object.values(extrinsics)) {\n      if (\n        tx.method === method &&\n        section === tx.section &&\n        tx.sender === sender\n      ) {\n        calls.push({ ...tx });\n      }\n    }\n\n    return calls;\n  }, [extrinsics]);\n\n  return extrinsicCalls;\n};\n"],"names":["putTransactionError","transactions","txHash","errorMessage","produce","draft","status","dispatchError","putBlockHash","blockHash","useStore","create","set","extrinsics","addExtrinsic","transactionHash","extrinsicCall","prev","data","addBlockHash","updateExtrinsicStatus","extrinsicStatus","updateExtrinsicError","extrinsicsSlice","Executor","updateExstrinsicStatus","this","execute","call","sender","api","signer","onTxReady","onTxFinalized","onTxError","_context","signAndSend","txResult","toString","toLowerCase","isReady","_this","onReady","error","onDispatchError","unsub","isFinalized","onFinalized","events","executeUnsigned","_context2","send","_this2","isInBlock","onBlockInclusion","isSigned","serialized","toHuman","payload","hash","method","section","args","undefined","timestamp","Date","now","isModule","decoded","registry","findMetaError","asModule","name","docs","join","asInBlock","ExecutorContext","React","createContext","executor","ParachainNetworks","picasso","wsUrl","tokenId","prefix","accountType","subscanUrl","decimals","color","symbol","logo","parachainId","relayChain","karura","RelayChainNetworks","kusama","networkId","polkadot","PARACHAIN_PROVIDERS_DEFAULT","Object","entries","map","chainId","parachainApi","apiStatus","accounts","reduce","acc","curr","RELAYCHAIN_PROVIDERS_DEFAULT","DotsamaContext","parachainProviders","relaychainProviders","extensionStatus","activate","selectedAccount","getSigner","applicationName","address","web3FromAddress","extensionPackage","web3Enable","supportedParachains","children","appName","useState","setParachainProviders","setExtension","s","extensionExists","extensionPkg","inectedExtesions","length","console","_loop","i","web3Accounts","ss58Format","x","meta","toFixed","setSelectedAccount","deactivate","_loop2","v","Promise","resolve","_context3","_ret2","extension","useEffect","rpc","types","wsProvider","WsProvider","rpcUrl","ApiPromise","provider","then","e","_loop3","Provider","value","useMemo","relaychainId","useContext","calls","values","tx","push","sort","a","b"],"mappings":"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"}